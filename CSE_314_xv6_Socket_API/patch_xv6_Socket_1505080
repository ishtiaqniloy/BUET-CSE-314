commit e37fe3b36369cc17e2a98e1905bc24fd2956d999
Author: ishtiaqniloy <1505080.aai@ugrad.cse.buet.ac.bd>
Date:   Sat Jan 19 20:27:16 2019 +0600

    Final4

diff --git a/.cvsignore b/.cvsignore
old mode 100644
new mode 100755
diff --git a/.dir-locals.el b/.dir-locals.el
old mode 100644
new mode 100755
diff --git a/.fuse_hidden0000067000000002 b/.fuse_hidden0000067000000002
new file mode 100755
index 0000000..b8a7353
--- /dev/null
+++ b/.fuse_hidden0000067000000002
@@ -0,0 +1,18 @@
+//
+// assembler macros to create x86 segments
+//
+
+#define SEG_NULLASM                                             \
+        .word 0, 0;                                             \
+        .byte 0, 0, 0, 0
+
+// The 0xC0 means the limit is in 4096-byte units
+// and (for executable segments) 32-bit mode.
+#define SEG_ASM(type,base,lim)                                  \
+        .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
+        .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
+                (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
+
+#define STA_X     0x8       // Executable segment
+#define STA_W     0x2       // Writeable (non-executable segments)
+#define STA_R     0x2       // Readable (executable segments)
diff --git a/.fuse_hidden000006c600000001 b/.fuse_hidden000006c600000001
new file mode 100755
index 0000000..ae6ae7e
--- /dev/null
+++ b/.fuse_hidden000006c600000001
@@ -0,0 +1,198 @@
+struct buf;
+struct context;
+struct file;
+struct inode;
+struct pipe;
+struct proc;
+struct rtcdate;
+struct spinlock;
+struct sleeplock;
+struct stat;
+struct superblock;
+
+// bio.c
+void            binit(void);
+struct buf*     bread(uint, uint);
+void            brelse(struct buf*);
+void            bwrite(struct buf*);
+
+// console.c
+void            consoleinit(void);
+void            cprintf(char*, ...);
+void            consoleintr(int(*)(void));
+void            panic(char*) __attribute__((noreturn));
+
+// exec.c
+int             exec(char*, char**);
+
+// file.c
+struct file*    filealloc(void);
+void            fileclose(struct file*);
+struct file*    filedup(struct file*);
+void            fileinit(void);
+int             fileread(struct file*, char*, int n);
+int             filestat(struct file*, struct stat*);
+int             filewrite(struct file*, char*, int n);
+
+// fs.c
+void            readsb(int dev, struct superblock *sb);
+int             dirlink(struct inode*, char*, uint);
+struct inode*   dirlookup(struct inode*, char*, uint*);
+struct inode*   ialloc(uint, short);
+struct inode*   idup(struct inode*);
+void            iinit(int dev);
+void            ilock(struct inode*);
+void            iput(struct inode*);
+void            iunlock(struct inode*);
+void            iunlockput(struct inode*);
+void            iupdate(struct inode*);
+int             namecmp(const char*, const char*);
+struct inode*   namei(char*);
+struct inode*   nameiparent(char*, char*);
+int             readi(struct inode*, char*, uint, uint);
+void            stati(struct inode*, struct stat*);
+int             writei(struct inode*, char*, uint, uint);
+
+// ide.c
+void            ideinit(void);
+void            ideintr(void);
+void            iderw(struct buf*);
+
+// ioapic.c
+void            ioapicenable(int irq, int cpu);
+extern uchar    ioapicid;
+void            ioapicinit(void);
+
+// kalloc.c
+char*           kalloc(void);
+void            kfree(char*);
+void            kinit1(void*, void*);
+void            kinit2(void*, void*);
+
+// kbd.c
+void            kbdintr(void);
+
+// lapic.c
+void            cmostime(struct rtcdate *r);
+int             lapicid(void);
+extern volatile uint*    lapic;
+void            lapiceoi(void);
+void            lapicinit(void);
+void            lapicstartap(uchar, uint);
+void            microdelay(int);
+
+// log.c
+void            initlog(int dev);
+void            log_write(struct buf*);
+void            begin_op();
+void            end_op();
+
+// mp.c
+extern int      ismp;
+void            mpinit(void);
+
+// picirq.c
+void            picenable(int);
+void            picinit(void);
+
+// pipe.c
+int             pipealloc(struct file**, struct file**);
+void            pipeclose(struct pipe*, int);
+int             piperead(struct pipe*, char*, int);
+int             pipewrite(struct pipe*, char*, int);
+
+//PAGEBREAK: 16
+// proc.c
+int             cpuid(void);
+void            exit(void);
+int             fork(void);
+int             growproc(int);
+int             kill(int);
+struct cpu*     mycpu(void);
+struct proc*    myproc();
+void            pinit(void);
+void            procdump(void);
+void            scheduler(void) __attribute__((noreturn));
+void            sched(void);
+void            setproc(struct proc*);
+void            sleep(void*, struct spinlock*);
+void            userinit(void);
+int             wait(void);
+void            wakeup(void*);
+void            yield(void);
+
+// sock.c
+void            sinit(void);
+int             listen(int);
+int             connect(int, const char*);
+int             send(int, const char*, int);
+int             recv(int, char*, int);
+int             disconnect(int);
+
+// swtch.S
+void            swtch(struct context**, struct context*);
+
+// spinlock.c
+void            acquire(struct spinlock*);
+void            getcallerpcs(void*, uint*);
+int             holding(struct spinlock*);
+void            initlock(struct spinlock*, char*);
+void            release(struct spinlock*);
+void            pushcli(void);
+void            popcli(void);
+
+// sleeplock.c
+void            acquiresleep(struct sleeplock*);
+void            releasesleep(struct sleeplock*);
+int             holdingsleep(struct sleeplock*);
+void            initsleeplock(struct sleeplock*, char*);
+
+// string.c
+int             memcmp(const void*, const void*, uint);
+void*           memmove(void*, const void*, uint);
+void*           memset(void*, int, uint);
+char*           safestrcpy(char*, const char*, int);
+int             strlen(const char*);
+int             strncmp(const char*, const char*, uint);
+char*           strncpy(char*, const char*, int);
+
+// syscall.c
+int             argint(int, int*);
+int             argptr(int, char**, int);
+int             argstr(int, char**);
+int             fetchint(uint, int*);
+int             fetchstr(uint, char**);
+void            syscall(void);
+
+// timer.c
+void            timerinit(void);
+
+// trap.c
+void            idtinit(void);
+extern uint     ticks;
+void            tvinit(void);
+extern struct spinlock tickslock;
+
+// uart.c
+void            uartinit(void);
+void            uartintr(void);
+void            uartputc(int);
+
+// vm.c
+void            seginit(void);
+void            kvmalloc(void);
+pde_t*          setupkvm(void);
+char*           uva2ka(pde_t*, char*);
+int             allocuvm(pde_t*, uint, uint);
+int             deallocuvm(pde_t*, uint, uint);
+void            freevm(pde_t*);
+void            inituvm(pde_t*, char*, uint);
+int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
+pde_t*          copyuvm(pde_t*, uint);
+void            switchuvm(struct proc*);
+void            switchkvm(void);
+int             copyout(pde_t*, uint, void*, uint);
+void            clearpteu(pde_t *pgdir, char *uva);
+
+// number of elements in fixed-size array
+#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/.gdbinit.tmpl b/.gdbinit.tmpl
old mode 100644
new mode 100755
diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/BUGS b/BUGS
old mode 100644
new mode 100755
diff --git a/LICENSE b/LICENSE
old mode 100644
new mode 100755
diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index 09d790c..d5274a1
--- a/Makefile
+++ b/Makefile
@@ -16,12 +16,14 @@ OBJS = \
 	pipe.o\
 	proc.o\
 	sleeplock.o\
+	sock.o\
 	spinlock.o\
 	string.o\
 	swtch.o\
 	syscall.o\
 	sysfile.o\
 	sysproc.o\
+	syssock.o\
 	trapasm.o\
 	trap.o\
 	uart.o\
@@ -32,7 +34,7 @@ OBJS = \
 # TOOLPREFIX = i386-jos-elf
 
 # Using native tools (e.g., on X86 Linux)
-#TOOLPREFIX = 
+#TOOLPREFIX =
 
 # Try to infer the correct TOOLPREFIX if not set
 ifndef TOOLPREFIX
@@ -162,7 +164,7 @@ mkfs: mkfs.c fs.h
 # Prevent deletion of intermediate files, e.g. cat.o, after first build, so
 # that disk image changes after first build are persistent until clean.  More
 # details:
-# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+# http:///www.gnu.org/software/make/manual/html_node/Chained-Rules.html
 .PRECIOUS: %.o
 
 UPROGS=\
@@ -181,13 +183,14 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_socktest\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
 
 -include *.d
 
-clean: 
+clean:
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*.o *.d *.asm *.sym vectors.S bootblock entryother \
 	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
diff --git a/Notes b/Notes
old mode 100644
new mode 100755
diff --git a/README b/README
old mode 100644
new mode 100755
index 9e3cf19..b855ede
--- a/README
+++ b/README
@@ -6,7 +6,7 @@ ACKNOWLEDGMENTS
 
 xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
 to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
-2000)). See also https://pdos.csail.mit.edu/6.828/, which
+2000)). See also https:///pdos.csail.mit.edu/6.828/, which
 provides pointers to on-line resources for v6.
 
 xv6 borrows code from the following sources:
@@ -45,6 +45,6 @@ BUILDING AND RUNNING XV6
 To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
 "make". On non-x86 or non-ELF machines (like OS X, even on x86), you
 will need to install a cross-compiler gcc suite capable of producing
-x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
+x86 ELF binaries (see https:///pdos.csail.mit.edu/6.828/).
 Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
 simulator and run "make qemu".
diff --git a/TRICKS b/TRICKS
old mode 100644
new mode 100755
index 8d1439f..243e790
--- a/TRICKS
+++ b/TRICKS
@@ -1,4 +1,4 @@
-This file lists subtle things that might not be commented 
+This file lists subtle things that might not be commented
 as well as they should be in the source code and that
 might be worth pointing out in a longer explanation or in class.
 
@@ -9,7 +9,7 @@ and this is now cleaner.]
 
 forkret1 in trapasm.S is called with a tf argument.
 In order to use it, forkret1 copies the tf pointer into
-%esp and then jumps to trapret, which pops the 
+%esp and then jumps to trapret, which pops the
 register state out of the trap frame.  If an interrupt
 came in between the mov tf, %esp and the iret that
 goes back out to user space, the interrupt stack frame
@@ -19,7 +19,7 @@ lay under it.
 Why is this safe?  Because forkret1 is only called
 the first time a process returns to user space, and
 at that point, cp->tf is set to point to a trap frame
-constructed at the top of cp's kernel stack.  So tf 
+constructed at the top of cp's kernel stack.  So tf
 *is* a valid %esp that can hold interrupt state.
 
 If other tf's were used in forkret1, we could add
@@ -37,7 +37,7 @@ because if interrupts are off then we might call cpu(), get
 rescheduled to a different cpu, look at cpus[oldcpu].ncli,
 and wrongly decide not to disable interrupts on the new cpu.
 
-Instead do 
+Instead do
 
   cli();
   cpus[cpu()].ncli++;
@@ -53,17 +53,17 @@ There is a (harmless) race in pushcli, which does
 	if(c->ncli++ == 0)
 		c->intena = eflags & FL_IF;
 
-Consider a bottom-level pushcli.  
+Consider a bottom-level pushcli.
 If interrupts are disabled already, then the right thing
 happens: read_eflags finds that FL_IF is not set,
 and intena = 0.  If interrupts are enabled, then
 it is less clear that the right thing happens:
 the readeflags can execute, then the process
 can get preempted and rescheduled on another cpu,
-and then once it starts running, perhaps with 
+and then once it starts running, perhaps with
 interrupts disabled (can happen since the scheduler
 only enables interrupts once per scheduling loop,
-not every time it schedules a process), it will 
+not every time it schedules a process), it will
 incorrectly record that interrupts *were* enabled.
 This doesn't matter, because if it was safe to be
 running with interrupts enabled before the context
@@ -76,10 +76,10 @@ before calling swtch, and perhaps it should.
 
 ---
 
-The x86's processor-ordering memory model 
+The x86's processor-ordering memory model
 matches spin locks well, so no explicit memory
 synchronization instructions are required in
-acquire and release.  
+acquire and release.
 
 Consider two sequences of code on different CPUs:
 
@@ -96,10 +96,10 @@ B;
 We want to make sure that:
   - all reads in B see the effects of writes in A.
   - all reads in A do *not* see the effects of writes in B.
- 
+
 The x86 guarantees that writes in A will go out
-to memory before the write of lk->locked = 0 in 
-release(lk).  It further guarantees that CPU1 
+to memory before the write of lk->locked = 0 in
+release(lk).  It further guarantees that CPU1
 will observe CPU0's write of lk->locked = 0 only
 after observing the earlier writes by CPU0.
 So any reads in B are guaranteed to observe the
@@ -124,7 +124,7 @@ is not a correct way to do this:
 	{
 	  ...
 	  np->state = RUNNABLE;
-	  return np->pid; // oops
+	  return np->pid; /// oops
 	}
 
 After setting np->state to RUNNABLE, some other CPU
diff --git a/asm.h b/asm.h
old mode 100644
new mode 100755
index b8a7353..9729e22
--- a/asm.h
+++ b/asm.h
@@ -1,18 +1,18 @@
-//
-// assembler macros to create x86 segments
-//
+///
+/// assembler macros to create x86 segments
+///
 
 #define SEG_NULLASM                                             \
         .word 0, 0;                                             \
         .byte 0, 0, 0, 0
 
-// The 0xC0 means the limit is in 4096-byte units
-// and (for executable segments) 32-bit mode.
+/// The 0xC0 means the limit is in 4096-byte units
+/// and (for executable segments) 32-bit mode.
 #define SEG_ASM(type,base,lim)                                  \
         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
 
-#define STA_X     0x8       // Executable segment
-#define STA_W     0x2       // Writeable (non-executable segments)
-#define STA_R     0x2       // Readable (executable segments)
+#define STA_X     0x8       /// Executable segment
+#define STA_W     0x2       /// Writeable (non-executable segments)
+#define STA_R     0x2       /// Readable (executable segments)
diff --git a/bio.c b/bio.c
old mode 100644
new mode 100755
index a45ff3e..426d845
--- a/bio.c
+++ b/bio.c
@@ -1,22 +1,22 @@
-// Buffer cache.
-//
-// The buffer cache is a linked list of buf structures holding
-// cached copies of disk block contents.  Caching disk blocks
-// in memory reduces the number of disk reads and also provides
-// a synchronization point for disk blocks used by multiple processes.
-//
-// Interface:
-// * To get a buffer for a particular disk block, call bread.
-// * After changing buffer data, call bwrite to write it to disk.
-// * When done with the buffer, call brelse.
-// * Do not use the buffer after calling brelse.
-// * Only one process at a time can use a buffer,
-//     so do not keep them longer than necessary.
-//
-// The implementation uses two state flags internally:
-// * B_VALID: the buffer data has been read from the disk.
-// * B_DIRTY: the buffer data has been modified
-//     and needs to be written to disk.
+/// Buffer cache.
+///
+/// The buffer cache is a linked list of buf structures holding
+/// cached copies of disk block contents.  Caching disk blocks
+/// in memory reduces the number of disk reads and also provides
+/// a synchronization point for disk blocks used by multiple processes.
+///
+/// Interface:
+/// * To get a buffer for a particular disk block, call bread.
+/// * After changing buffer data, call bwrite to write it to disk.
+/// * When done with the buffer, call brelse.
+/// * Do not use the buffer after calling brelse.
+/// * Only one process at a time can use a buffer,
+///     so do not keep them longer than necessary.
+///
+/// The implementation uses two state flags internally:
+/// * B_VALID: the buffer data has been read from the disk.
+/// * B_DIRTY: the buffer data has been modified
+///     and needs to be written to disk.
 
 #include "types.h"
 #include "defs.h"
@@ -30,8 +30,8 @@ struct {
   struct spinlock lock;
   struct buf buf[NBUF];
 
-  // Linked list of all buffers, through prev/next.
-  // head.next is most recently used.
+  /// Linked list of all buffers, through prev/next.
+  /// head.next is most recently used.
   struct buf head;
 } bcache;
 
@@ -42,8 +42,8 @@ binit(void)
 
   initlock(&bcache.lock, "bcache");
 
-//PAGEBREAK!
-  // Create linked list of buffers
+///PAGEBREAK!
+  /// Create linked list of buffers
   bcache.head.prev = &bcache.head;
   bcache.head.next = &bcache.head;
   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
@@ -55,9 +55,9 @@ binit(void)
   }
 }
 
-// Look through buffer cache for block on device dev.
-// If not found, allocate a buffer.
-// In either case, return locked buffer.
+/// Look through buffer cache for block on device dev.
+/// If not found, allocate a buffer.
+/// In either case, return locked buffer.
 static struct buf*
 bget(uint dev, uint blockno)
 {
@@ -65,7 +65,7 @@ bget(uint dev, uint blockno)
 
   acquire(&bcache.lock);
 
-  // Is the block already cached?
+  /// Is the block already cached?
   for(b = bcache.head.next; b != &bcache.head; b = b->next){
     if(b->dev == dev && b->blockno == blockno){
       b->refcnt++;
@@ -75,9 +75,9 @@ bget(uint dev, uint blockno)
     }
   }
 
-  // Not cached; recycle an unused buffer.
-  // Even if refcnt==0, B_DIRTY indicates a buffer is in use
-  // because log.c has modified it but not yet committed it.
+  /// Not cached; recycle an unused buffer.
+  /// Even if refcnt==0, B_DIRTY indicates a buffer is in use
+  /// because log.c has modified it but not yet committed it.
   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
       b->dev = dev;
@@ -92,7 +92,7 @@ bget(uint dev, uint blockno)
   panic("bget: no buffers");
 }
 
-// Return a locked buf with the contents of the indicated block.
+/// Return a locked buf with the contents of the indicated block.
 struct buf*
 bread(uint dev, uint blockno)
 {
@@ -105,7 +105,7 @@ bread(uint dev, uint blockno)
   return b;
 }
 
-// Write b's contents to disk.  Must be locked.
+/// Write b's contents to disk.  Must be locked.
 void
 bwrite(struct buf *b)
 {
@@ -115,8 +115,8 @@ bwrite(struct buf *b)
   iderw(b);
 }
 
-// Release a locked buffer.
-// Move to the head of the MRU list.
+/// Release a locked buffer.
+/// Move to the head of the MRU list.
 void
 brelse(struct buf *b)
 {
@@ -128,7 +128,7 @@ brelse(struct buf *b)
   acquire(&bcache.lock);
   b->refcnt--;
   if (b->refcnt == 0) {
-    // no one is waiting for it.
+    /// no one is waiting for it.
     b->next->prev = b->prev;
     b->prev->next = b->next;
     b->next = bcache.head.next;
@@ -136,9 +136,9 @@ brelse(struct buf *b)
     bcache.head.next->prev = b;
     bcache.head.next = b;
   }
-  
+
   release(&bcache.lock);
 }
-//PAGEBREAK!
-// Blank page.
+///PAGEBREAK!
+/// Blank page.
 
diff --git a/bootasm.S b/bootasm.S
old mode 100644
new mode 100755
index 257867c..59df3cf
--- a/bootasm.S
+++ b/bootasm.S
@@ -18,7 +18,7 @@ start:
   movw    %ax,%es             # -> Extra Segment
   movw    %ax,%ss             # -> Stack Segment
 
-  # Physical address line A20 is tied to zero so that the first PCs 
+  # Physical address line A20 is tied to zero so that the first PCs
   # with 2 MB would run software that assumed 1 MB.  Undo that.
 seta20.1:
   inb     $0x64,%al               # Wait for not busy
@@ -44,7 +44,7 @@ seta20.2:
   orl     $CR0_PE, %eax
   movl    %eax, %cr0
 
-//PAGEBREAK!
+///PAGEBREAK!
   # Complete the transition to 32-bit protected mode by using a long jmp
   # to reload %cs and %eip.  The segment descriptors are set up with no
   # translation, so that the mapping is still the identity mapping.
diff --git a/bootmain.c b/bootmain.c
old mode 100644
new mode 100755
index 1f20e5b..929f169
--- a/bootmain.c
+++ b/bootmain.c
@@ -1,9 +1,9 @@
-// Boot loader.
-//
-// Part of the boot block, along with bootasm.S, which calls bootmain().
-// bootasm.S has put the processor into protected 32-bit mode.
-// bootmain() loads an ELF kernel image from the disk starting at
-// sector 1 and then jumps to the kernel entry routine.
+/// Boot loader.
+///
+/// Part of the boot block, along with bootasm.S, which calls bootmain().
+/// bootasm.S has put the processor into protected 32-bit mode.
+/// bootmain() loads an ELF kernel image from the disk starting at
+/// sector 1 and then jumps to the kernel entry routine.
 
 #include "types.h"
 #include "elf.h"
@@ -22,16 +22,16 @@ bootmain(void)
   void (*entry)(void);
   uchar* pa;
 
-  elf = (struct elfhdr*)0x10000;  // scratch space
+  elf = (struct elfhdr*)0x10000;  /// scratch space
 
-  // Read 1st page off disk
+  /// Read 1st page off disk
   readseg((uchar*)elf, 4096, 0);
 
-  // Is this an ELF executable?
+  /// Is this an ELF executable?
   if(elf->magic != ELF_MAGIC)
-    return;  // let bootasm.S handle error
+    return;  /// let bootasm.S handle error
 
-  // Load each program segment (ignores ph flags).
+  /// Load each program segment (ignores ph flags).
   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
   eph = ph + elf->phnum;
   for(; ph < eph; ph++){
@@ -41,8 +41,8 @@ bootmain(void)
       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
   }
 
-  // Call the entry point from the ELF header.
-  // Does not return!
+  /// Call the entry point from the ELF header.
+  /// Does not return!
   entry = (void(*)(void))(elf->entry);
   entry();
 }
@@ -50,31 +50,31 @@ bootmain(void)
 void
 waitdisk(void)
 {
-  // Wait for disk ready.
+  /// Wait for disk ready.
   while((inb(0x1F7) & 0xC0) != 0x40)
     ;
 }
 
-// Read a single sector at offset into dst.
+/// Read a single sector at offset into dst.
 void
 readsect(void *dst, uint offset)
 {
-  // Issue command.
+  /// Issue command.
   waitdisk();
-  outb(0x1F2, 1);   // count = 1
+  outb(0x1F2, 1);   /// count = 1
   outb(0x1F3, offset);
   outb(0x1F4, offset >> 8);
   outb(0x1F5, offset >> 16);
   outb(0x1F6, (offset >> 24) | 0xE0);
-  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+  outb(0x1F7, 0x20);  /// cmd 0x20 - read sectors
 
-  // Read data.
+  /// Read data.
   waitdisk();
   insl(0x1F0, dst, SECTSIZE/4);
 }
 
-// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
-// Might copy more than asked.
+/// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
+/// Might copy more than asked.
 void
 readseg(uchar* pa, uint count, uint offset)
 {
@@ -82,15 +82,15 @@ readseg(uchar* pa, uint count, uint offset)
 
   epa = pa + count;
 
-  // Round down to sector boundary.
+  /// Round down to sector boundary.
   pa -= offset % SECTSIZE;
 
-  // Translate from bytes to sectors; kernel starts at sector 1.
+  /// Translate from bytes to sectors; kernel starts at sector 1.
   offset = (offset / SECTSIZE) + 1;
 
-  // If this is too slow, we could read lots of sectors at a time.
-  // We'd write more to memory than asked, but it doesn't matter --
-  // we load in increasing order.
+  /// If this is too slow, we could read lots of sectors at a time.
+  /// We'd write more to memory than asked, but it doesn't matter --
+  /// we load in increasing order.
   for(; pa < epa; pa += SECTSIZE, offset++)
     readsect(pa, offset);
 }
diff --git a/buf.h b/buf.h
old mode 100644
new mode 100755
index 3266495..d9bcb85
--- a/buf.h
+++ b/buf.h
@@ -4,11 +4,11 @@ struct buf {
   uint blockno;
   struct sleeplock lock;
   uint refcnt;
-  struct buf *prev; // LRU cache list
+  struct buf *prev; /// LRU cache list
   struct buf *next;
-  struct buf *qnext; // disk queue
+  struct buf *qnext; /// disk queue
   uchar data[BSIZE];
 };
-#define B_VALID 0x2  // buffer has been read from disk
-#define B_DIRTY 0x4  // buffer needs to be written to disk
+#define B_VALID 0x2  /// buffer has been read from disk
+#define B_DIRTY 0x4  /// buffer needs to be written to disk
 
diff --git a/cat.c b/cat.c
old mode 100644
new mode 100755
diff --git a/console.c b/console.c
old mode 100644
new mode 100755
index a280d2b..432417c
--- a/console.c
+++ b/console.c
@@ -1,6 +1,6 @@
-// Console input and output.
-// Input is from the keyboard or serial port.
-// Output is written to the screen and serial port.
+/// Console input and output.
+/// Input is from the keyboard or serial port.
+/// Output is written to the screen and serial port.
 
 #include "types.h"
 #include "defs.h"
@@ -48,9 +48,9 @@ printint(int xx, int base, int sign)
   while(--i >= 0)
     consputc(buf[i]);
 }
-//PAGEBREAK: 50
+///PAGEBREAK: 50
 
-// Print to the console. only understands %d, %x, %p, %s.
+/// Print to the console. only understands %d, %x, %p, %s.
 void
 cprintf(char *fmt, ...)
 {
@@ -92,7 +92,7 @@ cprintf(char *fmt, ...)
       consputc('%');
       break;
     default:
-      // Print unknown % sequence to draw attention.
+      /// Print unknown % sequence to draw attention.
       consputc('%');
       consputc(c);
       break;
@@ -111,29 +111,29 @@ panic(char *s)
 
   cli();
   cons.locking = 0;
-  // use lapiccpunum so that we can call panic from mycpu()
+  /// use lapiccpunum so that we can call panic from mycpu()
   cprintf("lapicid %d: panic: ", lapicid());
   cprintf(s);
   cprintf("\n");
   getcallerpcs(&s, pcs);
   for(i=0; i<10; i++)
     cprintf(" %p", pcs[i]);
-  panicked = 1; // freeze other CPU
+  panicked = 1; /// freeze other CPU
   for(;;)
     ;
 }
 
-//PAGEBREAK: 50
+///PAGEBREAK: 50
 #define BACKSPACE 0x100
 #define CRTPORT 0x3d4
-static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
+static ushort *crt = (ushort*)P2V(0xb8000);  /// CGA memory
 
 static void
 cgaputc(int c)
 {
   int pos;
 
-  // Cursor position: col + 80*row.
+  /// Cursor position: col + 80*row.
   outb(CRTPORT, 14);
   pos = inb(CRTPORT+1) << 8;
   outb(CRTPORT, 15);
@@ -144,12 +144,12 @@ cgaputc(int c)
   else if(c == BACKSPACE){
     if(pos > 0) --pos;
   } else
-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+    crt[pos++] = (c&0xff) | 0x0700;  /// black on white
 
   if(pos < 0 || pos > 25*80)
     panic("pos under/overflow");
 
-  if((pos/80) >= 24){  // Scroll up.
+  if((pos/80) >= 24){  /// Scroll up.
     memmove(crt, crt+80, sizeof(crt[0])*23*80);
     pos -= 80;
     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
@@ -181,12 +181,12 @@ consputc(int c)
 #define INPUT_BUF 128
 struct {
   char buf[INPUT_BUF];
-  uint r;  // Read index
-  uint w;  // Write index
-  uint e;  // Edit index
+  uint r;  /// Read index
+  uint w;  /// Write index
+  uint e;  /// Edit index
 } input;
 
-#define C(x)  ((x)-'@')  // Control-x
+#define C(x)  ((x)-'@')  /// Control-x
 
 void
 consoleintr(int (*getc)(void))
@@ -196,18 +196,18 @@ consoleintr(int (*getc)(void))
   acquire(&cons.lock);
   while((c = getc()) >= 0){
     switch(c){
-    case C('P'):  // Process listing.
-      // procdump() locks cons.lock indirectly; invoke later
+    case C('P'):  /// Process listing.
+      /// procdump() locks cons.lock indirectly; invoke later
       doprocdump = 1;
       break;
-    case C('U'):  // Kill line.
+    case C('U'):  /// Kill line.
       while(input.e != input.w &&
             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
         input.e--;
         consputc(BACKSPACE);
       }
       break;
-    case C('H'): case '\x7f':  // Backspace
+    case C('H'): case '\x7f':  /// Backspace
       if(input.e != input.w){
         input.e--;
         consputc(BACKSPACE);
@@ -228,7 +228,7 @@ consoleintr(int (*getc)(void))
   }
   release(&cons.lock);
   if(doprocdump) {
-    procdump();  // now call procdump() wo. cons.lock held
+    procdump();  /// now call procdump() wo. cons.lock held
   }
 }
 
@@ -251,10 +251,10 @@ consoleread(struct inode *ip, char *dst, int n)
       sleep(&input.r, &cons.lock);
     }
     c = input.buf[input.r++ % INPUT_BUF];
-    if(c == C('D')){  // EOF
+    if(c == C('D')){  /// EOF
       if(n < target){
-        // Save ^D for next time, to make sure
-        // caller gets a 0-byte result.
+        /// Save ^D for next time, to make sure
+        /// caller gets a 0-byte result.
         input.r--;
       }
       break;
diff --git a/date.h b/date.h
old mode 100644
new mode 100755
diff --git a/defs.h b/defs.h
old mode 100644
new mode 100755
index 82fb982..3f55efd
--- a/defs.h
+++ b/defs.h
@@ -10,22 +10,22 @@ struct sleeplock;
 struct stat;
 struct superblock;
 
-// bio.c
+/// bio.c
 void            binit(void);
 struct buf*     bread(uint, uint);
 void            brelse(struct buf*);
 void            bwrite(struct buf*);
 
-// console.c
+/// console.c
 void            consoleinit(void);
 void            cprintf(char*, ...);
 void            consoleintr(int(*)(void));
 void            panic(char*) __attribute__((noreturn));
 
-// exec.c
+/// exec.c
 int             exec(char*, char**);
 
-// file.c
+/// file.c
 struct file*    filealloc(void);
 void            fileclose(struct file*);
 struct file*    filedup(struct file*);
@@ -34,7 +34,7 @@ int             fileread(struct file*, char*, int n);
 int             filestat(struct file*, struct stat*);
 int             filewrite(struct file*, char*, int n);
 
-// fs.c
+/// fs.c
 void            readsb(int dev, struct superblock *sb);
 int             dirlink(struct inode*, char*, uint);
 struct inode*   dirlookup(struct inode*, char*, uint*);
@@ -53,26 +53,26 @@ int             readi(struct inode*, char*, uint, uint);
 void            stati(struct inode*, struct stat*);
 int             writei(struct inode*, char*, uint, uint);
 
-// ide.c
+/// ide.c
 void            ideinit(void);
 void            ideintr(void);
 void            iderw(struct buf*);
 
-// ioapic.c
+/// ioapic.c
 void            ioapicenable(int irq, int cpu);
 extern uchar    ioapicid;
 void            ioapicinit(void);
 
-// kalloc.c
+/// kalloc.c
 char*           kalloc(void);
 void            kfree(char*);
 void            kinit1(void*, void*);
 void            kinit2(void*, void*);
 
-// kbd.c
+/// kbd.c
 void            kbdintr(void);
 
-// lapic.c
+/// lapic.c
 void            cmostime(struct rtcdate *r);
 int             lapicid(void);
 extern volatile uint*    lapic;
@@ -81,28 +81,28 @@ void            lapicinit(void);
 void            lapicstartap(uchar, uint);
 void            microdelay(int);
 
-// log.c
+/// log.c
 void            initlog(int dev);
 void            log_write(struct buf*);
 void            begin_op();
 void            end_op();
 
-// mp.c
+/// mp.c
 extern int      ismp;
 void            mpinit(void);
 
-// picirq.c
+/// picirq.c
 void            picenable(int);
 void            picinit(void);
 
-// pipe.c
+/// pipe.c
 int             pipealloc(struct file**, struct file**);
 void            pipeclose(struct pipe*, int);
 int             piperead(struct pipe*, char*, int);
 int             pipewrite(struct pipe*, char*, int);
 
-//PAGEBREAK: 16
-// proc.c
+///PAGEBREAK: 16
+/// proc.c
 int             cpuid(void);
 void            exit(void);
 int             fork(void);
@@ -121,10 +121,18 @@ int             wait(void);
 void            wakeup(void*);
 void            yield(void);
 
-// swtch.S
+/// sock.c
+void            sinit(void);
+int             listen(int);
+int             connect(int, const char*);
+int             send(int, const char*, int);
+int             recv(int, char*, int);
+int             disconnect(int);
+
+/// swtch.S
 void            swtch(struct context**, struct context*);
 
-// spinlock.c
+/// spinlock.c
 void            acquire(struct spinlock*);
 void            getcallerpcs(void*, uint*);
 int             holding(struct spinlock*);
@@ -133,13 +141,13 @@ void            release(struct spinlock*);
 void            pushcli(void);
 void            popcli(void);
 
-// sleeplock.c
+/// sleeplock.c
 void            acquiresleep(struct sleeplock*);
 void            releasesleep(struct sleeplock*);
 int             holdingsleep(struct sleeplock*);
 void            initsleeplock(struct sleeplock*, char*);
 
-// string.c
+/// string.c
 int             memcmp(const void*, const void*, uint);
 void*           memmove(void*, const void*, uint);
 void*           memset(void*, int, uint);
@@ -148,7 +156,7 @@ int             strlen(const char*);
 int             strncmp(const char*, const char*, uint);
 char*           strncpy(char*, const char*, int);
 
-// syscall.c
+/// syscall.c
 int             argint(int, int*);
 int             argptr(int, char**, int);
 int             argstr(int, char**);
@@ -156,21 +164,21 @@ int             fetchint(uint, int*);
 int             fetchstr(uint, char**);
 void            syscall(void);
 
-// timer.c
+/// timer.c
 void            timerinit(void);
 
-// trap.c
+/// trap.c
 void            idtinit(void);
 extern uint     ticks;
 void            tvinit(void);
 extern struct spinlock tickslock;
 
-// uart.c
+/// uart.c
 void            uartinit(void);
 void            uartintr(void);
 void            uartputc(int);
 
-// vm.c
+/// vm.c
 void            seginit(void);
 void            kvmalloc(void);
 pde_t*          setupkvm(void);
@@ -186,5 +194,5 @@ void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
 
-// number of elements in fixed-size array
+/// number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/echo.c b/echo.c
old mode 100644
new mode 100755
diff --git a/elf.h b/elf.h
old mode 100644
new mode 100755
index d16c967..11dfd2e
--- a/elf.h
+++ b/elf.h
@@ -1,10 +1,10 @@
-// Format of an ELF executable file
+/// Format of an ELF executable file
 
-#define ELF_MAGIC 0x464C457FU  // "\x7FELF" in little endian
+#define ELF_MAGIC 0x464C457FU  /// "\x7FELF" in little endian
 
-// File header
+/// File header
 struct elfhdr {
-  uint magic;  // must equal ELF_MAGIC
+  uint magic;  /// must equal ELF_MAGIC
   uchar elf[12];
   ushort type;
   ushort machine;
@@ -21,7 +21,7 @@ struct elfhdr {
   ushort shstrndx;
 };
 
-// Program section header
+/// Program section header
 struct proghdr {
   uint type;
   uint off;
@@ -33,10 +33,10 @@ struct proghdr {
   uint align;
 };
 
-// Values for Proghdr type
+/// Values for Proghdr type
 #define ELF_PROG_LOAD           1
 
-// Flag bits for Proghdr flags
+/// Flag bits for Proghdr flags
 #define ELF_PROG_FLAG_EXEC      1
 #define ELF_PROG_FLAG_WRITE     2
 #define ELF_PROG_FLAG_READ      4
diff --git a/entry.S b/entry.S
old mode 100644
new mode 100755
index bc79bab..bf6ec35
--- a/entry.S
+++ b/entry.S
@@ -1,9 +1,9 @@
 # The xv6 kernel starts executing in this file. This file is linked with
 # the kernel C code, so it can refer to kernel symbols such as main().
 # The boot block (bootasm.S and bootmain.c) jumps to entry below.
-        
+
 # Multiboot header, for multiboot boot loaders like GNU Grub.
-# http://www.gnu.org/software/grub/manual/multiboot/multiboot.html
+# http:///www.gnu.org/software/grub/manual/multiboot/multiboot.html
 #
 # Using GRUB 2, you can boot xv6 from a file stored in a
 # Linux file system by copying kernel or kernelmemfs to /boot
diff --git a/entryother.S b/entryother.S
old mode 100644
new mode 100755
index a3b6dc2..2c62830
--- a/entryother.S
+++ b/entryother.S
@@ -1,7 +1,7 @@
 #include "asm.h"
 #include "memlayout.h"
 #include "mmu.h"
-	
+
 # Each non-boot CPU ("AP") is started up in response to a STARTUP
 # IPI from the boot CPU.  Section B.4.2 of the Multi-Processor
 # Specification says that the AP will start in real mode with CS:IP
@@ -19,10 +19,10 @@
 #
 # This code combines elements of bootasm.S and entry.S.
 
-.code16           
+.code16
 .globl start
 start:
-  cli            
+  cli
 
   # Zero data segment registers DS, ES, and SS.
   xorw    %ax,%ax
@@ -43,7 +43,7 @@ start:
   # translation, so that the mapping is still the identity mapping.
   ljmpl    $(SEG_KCODE<<3), $(start32)
 
-//PAGEBREAK!
+///PAGEBREAK!
 .code32  # Tell assembler to generate 32-bit code now.
 start32:
   # Set up the protected-mode data segment registers
diff --git a/exec.c b/exec.c
old mode 100644
new mode 100755
index b40134f..7509f6c
--- a/exec.c
+++ b/exec.c
@@ -29,7 +29,7 @@ exec(char *path, char **argv)
   ilock(ip);
   pgdir = 0;
 
-  // Check ELF header
+  /// Check ELF header
   if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
     goto bad;
   if(elf.magic != ELF_MAGIC)
@@ -38,7 +38,7 @@ exec(char *path, char **argv)
   if((pgdir = setupkvm()) == 0)
     goto bad;
 
-  // Load program into memory.
+  /// Load program into memory.
   sz = 0;
   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
@@ -60,15 +60,15 @@ exec(char *path, char **argv)
   end_op();
   ip = 0;
 
-  // Allocate two pages at the next page boundary.
-  // Make the first inaccessible.  Use the second as the user stack.
+  /// Allocate two pages at the next page boundary.
+  /// Make the first inaccessible.  Use the second as the user stack.
   sz = PGROUNDUP(sz);
   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
     goto bad;
   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
   sp = sz;
 
-  // Push argument strings, prepare rest of stack in ustack.
+  /// Push argument strings, prepare rest of stack in ustack.
   for(argc = 0; argv[argc]; argc++) {
     if(argc >= MAXARG)
       goto bad;
@@ -79,25 +79,25 @@ exec(char *path, char **argv)
   }
   ustack[3+argc] = 0;
 
-  ustack[0] = 0xffffffff;  // fake return PC
+  ustack[0] = 0xffffffff;  /// fake return PC
   ustack[1] = argc;
-  ustack[2] = sp - (argc+1)*4;  // argv pointer
+  ustack[2] = sp - (argc+1)*4;  /// argv pointer
 
   sp -= (3+argc+1) * 4;
   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
     goto bad;
 
-  // Save program name for debugging.
+  /// Save program name for debugging.
   for(last=s=path; *s; s++)
     if(*s == '/')
       last = s+1;
   safestrcpy(curproc->name, last, sizeof(curproc->name));
 
-  // Commit to the user image.
+  /// Commit to the user image.
   oldpgdir = curproc->pgdir;
   curproc->pgdir = pgdir;
   curproc->sz = sz;
-  curproc->tf->eip = elf.entry;  // main
+  curproc->tf->eip = elf.entry;  /// main
   curproc->tf->esp = sp;
   switchuvm(curproc);
   freevm(oldpgdir);
diff --git a/fcntl.h b/fcntl.h
old mode 100644
new mode 100755
diff --git a/file.c b/file.c
old mode 100644
new mode 100755
index 24b32c2..e67d2c7
--- a/file.c
+++ b/file.c
@@ -1,6 +1,6 @@
-//
-// File descriptors
-//
+///
+/// File descriptors
+///
 
 #include "types.h"
 #include "defs.h"
@@ -22,7 +22,7 @@ fileinit(void)
   initlock(&ftable.lock, "ftable");
 }
 
-// Allocate a file structure.
+/// Allocate a file structure.
 struct file*
 filealloc(void)
 {
@@ -40,7 +40,7 @@ filealloc(void)
   return 0;
 }
 
-// Increment ref count for file f.
+/// Increment ref count for file f.
 struct file*
 filedup(struct file *f)
 {
@@ -52,7 +52,7 @@ filedup(struct file *f)
   return f;
 }
 
-// Close file f.  (Decrement ref count, close when reaches 0.)
+/// Close file f.  (Decrement ref count, close when reaches 0.)
 void
 fileclose(struct file *f)
 {
@@ -79,7 +79,7 @@ fileclose(struct file *f)
   }
 }
 
-// Get metadata about file f.
+/// Get metadata about file f.
 int
 filestat(struct file *f, struct stat *st)
 {
@@ -92,7 +92,7 @@ filestat(struct file *f, struct stat *st)
   return -1;
 }
 
-// Read from file f.
+/// Read from file f.
 int
 fileread(struct file *f, char *addr, int n)
 {
@@ -112,8 +112,8 @@ fileread(struct file *f, char *addr, int n)
   panic("fileread");
 }
 
-//PAGEBREAK!
-// Write to file f.
+///PAGEBREAK!
+/// Write to file f.
 int
 filewrite(struct file *f, char *addr, int n)
 {
@@ -124,12 +124,12 @@ filewrite(struct file *f, char *addr, int n)
   if(f->type == FD_PIPE)
     return pipewrite(f->pipe, addr, n);
   if(f->type == FD_INODE){
-    // write a few blocks at a time to avoid exceeding
-    // the maximum log transaction size, including
-    // i-node, indirect block, allocation blocks,
-    // and 2 blocks of slop for non-aligned writes.
-    // this really belongs lower down, since writei()
-    // might be writing a device like the console.
+    /// write a few blocks at a time to avoid exceeding
+    /// the maximum log transaction size, including
+    /// i-node, indirect block, allocation blocks,
+    /// and 2 blocks of slop for non-aligned writes.
+    /// this really belongs lower down, since writei()
+    /// might be writing a device like the console.
     int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
     int i = 0;
     while(i < n){
diff --git a/file.h b/file.h
old mode 100644
new mode 100755
index 0990c82..92cca9f
--- a/file.h
+++ b/file.h
@@ -1,6 +1,6 @@
 struct file {
   enum { FD_NONE, FD_PIPE, FD_INODE } type;
-  int ref; // reference count
+  int ref; /// reference count
   char readable;
   char writable;
   struct pipe *pipe;
@@ -9,15 +9,15 @@ struct file {
 };
 
 
-// in-memory copy of an inode
+/// in-memory copy of an inode
 struct inode {
-  uint dev;           // Device number
-  uint inum;          // Inode number
-  int ref;            // Reference count
-  struct sleeplock lock; // protects everything below here
-  int valid;          // inode has been read from disk?
+  uint dev;           /// Device number
+  uint inum;          /// Inode number
+  int ref;            /// Reference count
+  struct sleeplock lock; /// protects everything below here
+  int valid;          /// inode has been read from disk?
 
-  short type;         // copy of disk inode
+  short type;         /// copy of disk inode
   short major;
   short minor;
   short nlink;
@@ -25,8 +25,8 @@ struct inode {
   uint addrs[NDIRECT+1];
 };
 
-// table mapping major device number to
-// device functions
+/// table mapping major device number to
+/// device functions
 struct devsw {
   int (*read)(struct inode*, char*, int);
   int (*write)(struct inode*, char*, int);
diff --git a/forktest.c b/forktest.c
old mode 100644
new mode 100755
index 8bc984d..a9c648b
--- a/forktest.c
+++ b/forktest.c
@@ -1,5 +1,5 @@
-// Test that fork fails gracefully.
-// Tiny executable so that the limit can be filling the proc table.
+/// Test that fork fails gracefully.
+/// Tiny executable so that the limit can be filling the proc table.
 
 #include "types.h"
 #include "stat.h"
diff --git a/fs.c b/fs.c
old mode 100644
new mode 100755
index feb59fe..461a257
--- a/fs.c
+++ b/fs.c
@@ -1,13 +1,13 @@
-// File system implementation.  Five layers:
-//   + Blocks: allocator for raw disk blocks.
-//   + Log: crash recovery for multi-step updates.
-//   + Files: inode allocator, reading, writing, metadata.
-//   + Directories: inode with special contents (list of other inodes!)
-//   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
-//
-// This file contains the low-level file system manipulation
-// routines.  The (higher-level) system call implementations
-// are in sysfile.c.
+/// File system implementation.  Five layers:
+///   + Blocks: allocator for raw disk blocks.
+///   + Log: crash recovery for multi-step updates.
+///   + Files: inode allocator, reading, writing, metadata.
+///   + Directories: inode with special contents (list of other inodes!)
+///   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
+///
+/// This file contains the low-level file system manipulation
+/// routines.  The (higher-level) system call implementations
+/// are in sysfile.c.
 
 #include "types.h"
 #include "defs.h"
@@ -23,11 +23,11 @@
 
 #define min(a, b) ((a) < (b) ? (a) : (b))
 static void itrunc(struct inode*);
-// there should be one superblock per disk device, but we run with
-// only one device
-struct superblock sb; 
+/// there should be one superblock per disk device, but we run with
+/// only one device
+struct superblock sb;
 
-// Read the super block.
+/// Read the super block.
 void
 readsb(int dev, struct superblock *sb)
 {
@@ -38,7 +38,7 @@ readsb(int dev, struct superblock *sb)
   brelse(bp);
 }
 
-// Zero a block.
+/// Zero a block.
 static void
 bzero(int dev, int bno)
 {
@@ -50,9 +50,9 @@ bzero(int dev, int bno)
   brelse(bp);
 }
 
-// Blocks.
+/// Blocks.
 
-// Allocate a zeroed disk block.
+/// Allocate a zeroed disk block.
 static uint
 balloc(uint dev)
 {
@@ -64,8 +64,8 @@ balloc(uint dev)
     bp = bread(dev, BBLOCK(b, sb));
     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
       m = 1 << (bi % 8);
-      if((bp->data[bi/8] & m) == 0){  // Is block free?
-        bp->data[bi/8] |= m;  // Mark block in use.
+      if((bp->data[bi/8] & m) == 0){  /// Is block free?
+        bp->data[bi/8] |= m;  /// Mark block in use.
         log_write(bp);
         brelse(bp);
         bzero(dev, b + bi);
@@ -77,7 +77,7 @@ balloc(uint dev)
   panic("balloc: out of blocks");
 }
 
-// Free a disk block.
+/// Free a disk block.
 static void
 bfree(int dev, uint b)
 {
@@ -95,74 +95,74 @@ bfree(int dev, uint b)
   brelse(bp);
 }
 
-// Inodes.
-//
-// An inode describes a single unnamed file.
-// The inode disk structure holds metadata: the file's type,
-// its size, the number of links referring to it, and the
-// list of blocks holding the file's content.
-//
-// The inodes are laid out sequentially on disk at
-// sb.startinode. Each inode has a number, indicating its
-// position on the disk.
-//
-// The kernel keeps a cache of in-use inodes in memory
-// to provide a place for synchronizing access
-// to inodes used by multiple processes. The cached
-// inodes include book-keeping information that is
-// not stored on disk: ip->ref and ip->valid.
-//
-// An inode and its in-memory representation go through a
-// sequence of states before they can be used by the
-// rest of the file system code.
-//
-// * Allocation: an inode is allocated if its type (on disk)
-//   is non-zero. ialloc() allocates, and iput() frees if
-//   the reference and link counts have fallen to zero.
-//
-// * Referencing in cache: an entry in the inode cache
-//   is free if ip->ref is zero. Otherwise ip->ref tracks
-//   the number of in-memory pointers to the entry (open
-//   files and current directories). iget() finds or
-//   creates a cache entry and increments its ref; iput()
-//   decrements ref.
-//
-// * Valid: the information (type, size, &c) in an inode
-//   cache entry is only correct when ip->valid is 1.
-//   ilock() reads the inode from
-//   the disk and sets ip->valid, while iput() clears
-//   ip->valid if ip->ref has fallen to zero.
-//
-// * Locked: file system code may only examine and modify
-//   the information in an inode and its content if it
-//   has first locked the inode.
-//
-// Thus a typical sequence is:
-//   ip = iget(dev, inum)
-//   ilock(ip)
-//   ... examine and modify ip->xxx ...
-//   iunlock(ip)
-//   iput(ip)
-//
-// ilock() is separate from iget() so that system calls can
-// get a long-term reference to an inode (as for an open file)
-// and only lock it for short periods (e.g., in read()).
-// The separation also helps avoid deadlock and races during
-// pathname lookup. iget() increments ip->ref so that the inode
-// stays cached and pointers to it remain valid.
-//
-// Many internal file system functions expect the caller to
-// have locked the inodes involved; this lets callers create
-// multi-step atomic operations.
-//
-// The icache.lock spin-lock protects the allocation of icache
-// entries. Since ip->ref indicates whether an entry is free,
-// and ip->dev and ip->inum indicate which i-node an entry
-// holds, one must hold icache.lock while using any of those fields.
-//
-// An ip->lock sleep-lock protects all ip-> fields other than ref,
-// dev, and inum.  One must hold ip->lock in order to
-// read or write that inode's ip->valid, ip->size, ip->type, &c.
+/// Inodes.
+///
+/// An inode describes a single unnamed file.
+/// The inode disk structure holds metadata: the file's type,
+/// its size, the number of links referring to it, and the
+/// list of blocks holding the file's content.
+///
+/// The inodes are laid out sequentially on disk at
+/// sb.startinode. Each inode has a number, indicating its
+/// position on the disk.
+///
+/// The kernel keeps a cache of in-use inodes in memory
+/// to provide a place for synchronizing access
+/// to inodes used by multiple processes. The cached
+/// inodes include book-keeping information that is
+/// not stored on disk: ip->ref and ip->valid.
+///
+/// An inode and its in-memory representation go through a
+/// sequence of states before they can be used by the
+/// rest of the file system code.
+///
+/// * Allocation: an inode is allocated if its type (on disk)
+///   is non-zero. ialloc() allocates, and iput() frees if
+///   the reference and link counts have fallen to zero.
+///
+/// * Referencing in cache: an entry in the inode cache
+///   is free if ip->ref is zero. Otherwise ip->ref tracks
+///   the number of in-memory pointers to the entry (open
+///   files and current directories). iget() finds or
+///   creates a cache entry and increments its ref; iput()
+///   decrements ref.
+///
+/// * Valid: the information (type, size, &c) in an inode
+///   cache entry is only correct when ip->valid is 1.
+///   ilock() reads the inode from
+///   the disk and sets ip->valid, while iput() clears
+///   ip->valid if ip->ref has fallen to zero.
+///
+/// * Locked: file system code may only examine and modify
+///   the information in an inode and its content if it
+///   has first locked the inode.
+///
+/// Thus a typical sequence is:
+///   ip = iget(dev, inum)
+///   ilock(ip)
+///   ... examine and modify ip->xxx ...
+///   iunlock(ip)
+///   iput(ip)
+///
+/// ilock() is separate from iget() so that system calls can
+/// get a long-term reference to an inode (as for an open file)
+/// and only lock it for short periods (e.g., in read()).
+/// The separation also helps avoid deadlock and races during
+/// pathname lookup. iget() increments ip->ref so that the inode
+/// stays cached and pointers to it remain valid.
+///
+/// Many internal file system functions expect the caller to
+/// have locked the inodes involved; this lets callers create
+/// multi-step atomic operations.
+///
+/// The icache.lock spin-lock protects the allocation of icache
+/// entries. Since ip->ref indicates whether an entry is free,
+/// and ip->dev and ip->inum indicate which i-node an entry
+/// holds, one must hold icache.lock while using any of those fields.
+///
+/// An ip->lock sleep-lock protects all ip-> fields other than ref,
+/// dev, and inum.  One must hold ip->lock in order to
+/// read or write that inode's ip->valid, ip->size, ip->type, &c.
 
 struct {
   struct spinlock lock;
@@ -173,7 +173,7 @@ void
 iinit(int dev)
 {
   int i = 0;
-  
+
   initlock(&icache.lock, "icache");
   for(i = 0; i < NINODE; i++) {
     initsleeplock(&icache.inode[i].lock, "inode");
@@ -188,10 +188,10 @@ iinit(int dev)
 
 static struct inode* iget(uint dev, uint inum);
 
-//PAGEBREAK!
-// Allocate an inode on device dev.
-// Mark it as allocated by  giving it type type.
-// Returns an unlocked but allocated and referenced inode.
+///PAGEBREAK!
+/// Allocate an inode on device dev.
+/// Mark it as allocated by  giving it type type.
+/// Returns an unlocked but allocated and referenced inode.
 struct inode*
 ialloc(uint dev, short type)
 {
@@ -202,10 +202,10 @@ ialloc(uint dev, short type)
   for(inum = 1; inum < sb.ninodes; inum++){
     bp = bread(dev, IBLOCK(inum, sb));
     dip = (struct dinode*)bp->data + inum%IPB;
-    if(dip->type == 0){  // a free inode
+    if(dip->type == 0){  /// a free inode
       memset(dip, 0, sizeof(*dip));
       dip->type = type;
-      log_write(bp);   // mark it allocated on the disk
+      log_write(bp);   /// mark it allocated on the disk
       brelse(bp);
       return iget(dev, inum);
     }
@@ -214,10 +214,10 @@ ialloc(uint dev, short type)
   panic("ialloc: no inodes");
 }
 
-// Copy a modified in-memory inode to disk.
-// Must be called after every change to an ip->xxx field
-// that lives on disk, since i-node cache is write-through.
-// Caller must hold ip->lock.
+/// Copy a modified in-memory inode to disk.
+/// Must be called after every change to an ip->xxx field
+/// that lives on disk, since i-node cache is write-through.
+/// Caller must hold ip->lock.
 void
 iupdate(struct inode *ip)
 {
@@ -236,9 +236,9 @@ iupdate(struct inode *ip)
   brelse(bp);
 }
 
-// Find the inode with number inum on device dev
-// and return the in-memory copy. Does not lock
-// the inode and does not read it from disk.
+/// Find the inode with number inum on device dev
+/// and return the in-memory copy. Does not lock
+/// the inode and does not read it from disk.
 static struct inode*
 iget(uint dev, uint inum)
 {
@@ -246,7 +246,7 @@ iget(uint dev, uint inum)
 
   acquire(&icache.lock);
 
-  // Is the inode already cached?
+  /// Is the inode already cached?
   empty = 0;
   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
@@ -254,11 +254,11 @@ iget(uint dev, uint inum)
       release(&icache.lock);
       return ip;
     }
-    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+    if(empty == 0 && ip->ref == 0)    /// Remember empty slot.
       empty = ip;
   }
 
-  // Recycle an inode cache entry.
+  /// Recycle an inode cache entry.
   if(empty == 0)
     panic("iget: no inodes");
 
@@ -272,8 +272,8 @@ iget(uint dev, uint inum)
   return ip;
 }
 
-// Increment reference count for ip.
-// Returns ip to enable ip = idup(ip1) idiom.
+/// Increment reference count for ip.
+/// Returns ip to enable ip = idup(ip1) idiom.
 struct inode*
 idup(struct inode *ip)
 {
@@ -283,8 +283,8 @@ idup(struct inode *ip)
   return ip;
 }
 
-// Lock the given inode.
-// Reads the inode from disk if necessary.
+/// Lock the given inode.
+/// Reads the inode from disk if necessary.
 void
 ilock(struct inode *ip)
 {
@@ -312,7 +312,7 @@ ilock(struct inode *ip)
   }
 }
 
-// Unlock the given inode.
+/// Unlock the given inode.
 void
 iunlock(struct inode *ip)
 {
@@ -322,13 +322,13 @@ iunlock(struct inode *ip)
   releasesleep(&ip->lock);
 }
 
-// Drop a reference to an in-memory inode.
-// If that was the last reference, the inode cache entry can
-// be recycled.
-// If that was the last reference and the inode has no links
-// to it, free the inode (and its content) on disk.
-// All calls to iput() must be inside a transaction in
-// case it has to free the inode.
+/// Drop a reference to an in-memory inode.
+/// If that was the last reference, the inode cache entry can
+/// be recycled.
+/// If that was the last reference and the inode has no links
+/// to it, free the inode (and its content) on disk.
+/// All calls to iput() must be inside a transaction in
+/// case it has to free the inode.
 void
 iput(struct inode *ip)
 {
@@ -338,7 +338,7 @@ iput(struct inode *ip)
     int r = ip->ref;
     release(&icache.lock);
     if(r == 1){
-      // inode has no links and no other references: truncate and free.
+      /// inode has no links and no other references: truncate and free.
       itrunc(ip);
       ip->type = 0;
       iupdate(ip);
@@ -352,7 +352,7 @@ iput(struct inode *ip)
   release(&icache.lock);
 }
 
-// Common idiom: unlock, then put.
+/// Common idiom: unlock, then put.
 void
 iunlockput(struct inode *ip)
 {
@@ -360,16 +360,16 @@ iunlockput(struct inode *ip)
   iput(ip);
 }
 
-//PAGEBREAK!
-// Inode content
-//
-// The content (data) associated with each inode is stored
-// in blocks on the disk. The first NDIRECT block numbers
-// are listed in ip->addrs[].  The next NINDIRECT blocks are
-// listed in block ip->addrs[NDIRECT].
+///PAGEBREAK!
+/// Inode content
+///
+/// The content (data) associated with each inode is stored
+/// in blocks on the disk. The first NDIRECT block numbers
+/// are listed in ip->addrs[].  The next NINDIRECT blocks are
+/// listed in block ip->addrs[NDIRECT].
 
-// Return the disk block address of the nth block in inode ip.
-// If there is no such block, bmap allocates one.
+/// Return the disk block address of the nth block in inode ip.
+/// If there is no such block, bmap allocates one.
 static uint
 bmap(struct inode *ip, uint bn)
 {
@@ -384,7 +384,7 @@ bmap(struct inode *ip, uint bn)
   bn -= NDIRECT;
 
   if(bn < NINDIRECT){
-    // Load indirect block, allocating if necessary.
+    /// Load indirect block, allocating if necessary.
     if((addr = ip->addrs[NDIRECT]) == 0)
       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
     bp = bread(ip->dev, addr);
@@ -400,11 +400,11 @@ bmap(struct inode *ip, uint bn)
   panic("bmap: out of range");
 }
 
-// Truncate inode (discard contents).
-// Only called when the inode has no links
-// to it (no directory entries referring to it)
-// and has no in-memory reference to it (is
-// not an open file or current directory).
+/// Truncate inode (discard contents).
+/// Only called when the inode has no links
+/// to it (no directory entries referring to it)
+/// and has no in-memory reference to it (is
+/// not an open file or current directory).
 static void
 itrunc(struct inode *ip)
 {
@@ -435,8 +435,8 @@ itrunc(struct inode *ip)
   iupdate(ip);
 }
 
-// Copy stat information from inode.
-// Caller must hold ip->lock.
+/// Copy stat information from inode.
+/// Caller must hold ip->lock.
 void
 stati(struct inode *ip, struct stat *st)
 {
@@ -447,9 +447,9 @@ stati(struct inode *ip, struct stat *st)
   st->size = ip->size;
 }
 
-//PAGEBREAK!
-// Read data from inode.
-// Caller must hold ip->lock.
+///PAGEBREAK!
+/// Read data from inode.
+/// Caller must hold ip->lock.
 int
 readi(struct inode *ip, char *dst, uint off, uint n)
 {
@@ -476,9 +476,9 @@ readi(struct inode *ip, char *dst, uint off, uint n)
   return n;
 }
 
-// PAGEBREAK!
-// Write data to inode.
-// Caller must hold ip->lock.
+/// PAGEBREAK!
+/// Write data to inode.
+/// Caller must hold ip->lock.
 int
 writei(struct inode *ip, char *src, uint off, uint n)
 {
@@ -511,8 +511,8 @@ writei(struct inode *ip, char *src, uint off, uint n)
   return n;
 }
 
-//PAGEBREAK!
-// Directories
+///PAGEBREAK!
+/// Directories
 
 int
 namecmp(const char *s, const char *t)
@@ -520,8 +520,8 @@ namecmp(const char *s, const char *t)
   return strncmp(s, t, DIRSIZ);
 }
 
-// Look for a directory entry in a directory.
-// If found, set *poff to byte offset of entry.
+/// Look for a directory entry in a directory.
+/// If found, set *poff to byte offset of entry.
 struct inode*
 dirlookup(struct inode *dp, char *name, uint *poff)
 {
@@ -537,7 +537,7 @@ dirlookup(struct inode *dp, char *name, uint *poff)
     if(de.inum == 0)
       continue;
     if(namecmp(name, de.name) == 0){
-      // entry matches path element
+      /// entry matches path element
       if(poff)
         *poff = off;
       inum = de.inum;
@@ -548,7 +548,7 @@ dirlookup(struct inode *dp, char *name, uint *poff)
   return 0;
 }
 
-// Write a new directory entry (name, inum) into the directory dp.
+/// Write a new directory entry (name, inum) into the directory dp.
 int
 dirlink(struct inode *dp, char *name, uint inum)
 {
@@ -556,13 +556,13 @@ dirlink(struct inode *dp, char *name, uint inum)
   struct dirent de;
   struct inode *ip;
 
-  // Check that name is not present.
+  /// Check that name is not present.
   if((ip = dirlookup(dp, name, 0)) != 0){
     iput(ip);
     return -1;
   }
 
-  // Look for an empty dirent.
+  /// Look for an empty dirent.
   for(off = 0; off < dp->size; off += sizeof(de)){
     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
       panic("dirlink read");
@@ -578,21 +578,21 @@ dirlink(struct inode *dp, char *name, uint inum)
   return 0;
 }
 
-//PAGEBREAK!
-// Paths
-
-// Copy the next path element from path into name.
-// Return a pointer to the element following the copied one.
-// The returned path has no leading slashes,
-// so the caller can check *path=='\0' to see if the name is the last one.
-// If no name to remove, return 0.
-//
-// Examples:
-//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
-//   skipelem("///a//bb", name) = "bb", setting name = "a"
-//   skipelem("a", name) = "", setting name = "a"
-//   skipelem("", name) = skipelem("////", name) = 0
-//
+///PAGEBREAK!
+/// Paths
+
+/// Copy the next path element from path into name.
+/// Return a pointer to the element following the copied one.
+/// The returned path has no leading slashes,
+/// so the caller can check *path=='\0' to see if the name is the last one.
+/// If no name to remove, return 0.
+///
+/// Examples:
+///   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
+///   skipelem("////a///bb", name) = "bb", setting name = "a"
+///   skipelem("a", name) = "", setting name = "a"
+///   skipelem("", name) = skipelem("//////", name) = 0
+///
 static char*
 skipelem(char *path, char *name)
 {
@@ -618,10 +618,10 @@ skipelem(char *path, char *name)
   return path;
 }
 
-// Look up and return the inode for a path name.
-// If parent != 0, return the inode for the parent and copy the final
-// path element into name, which must have room for DIRSIZ bytes.
-// Must be called inside a transaction since it calls iput().
+/// Look up and return the inode for a path name.
+/// If parent != 0, return the inode for the parent and copy the final
+/// path element into name, which must have room for DIRSIZ bytes.
+/// Must be called inside a transaction since it calls iput().
 static struct inode*
 namex(char *path, int nameiparent, char *name)
 {
@@ -639,7 +639,7 @@ namex(char *path, int nameiparent, char *name)
       return 0;
     }
     if(nameiparent && *path == '\0'){
-      // Stop one level early.
+      /// Stop one level early.
       iunlock(ip);
       return ip;
     }
diff --git a/fs.h b/fs.h
old mode 100644
new mode 100755
index 3214f1d..fa7732c
--- a/fs.h
+++ b/fs.h
@@ -1,53 +1,53 @@
-// On-disk file system format.
-// Both the kernel and user programs use this header file.
+/// On-disk file system format.
+/// Both the kernel and user programs use this header file.
 
 
-#define ROOTINO 1  // root i-number
-#define BSIZE 512  // block size
+#define ROOTINO 1  /// root i-number
+#define BSIZE 512  /// block size
 
-// Disk layout:
-// [ boot block | super block | log | inode blocks |
-//                                          free bit map | data blocks]
-//
-// mkfs computes the super block and builds an initial file system. The
-// super block describes the disk layout:
+/// Disk layout:
+/// [ boot block | super block | log | inode blocks |
+///                                          free bit map | data blocks]
+///
+/// mkfs computes the super block and builds an initial file system. The
+/// super block describes the disk layout:
 struct superblock {
-  uint size;         // Size of file system image (blocks)
-  uint nblocks;      // Number of data blocks
-  uint ninodes;      // Number of inodes.
-  uint nlog;         // Number of log blocks
-  uint logstart;     // Block number of first log block
-  uint inodestart;   // Block number of first inode block
-  uint bmapstart;    // Block number of first free map block
+  uint size;         /// Size of file system image (blocks)
+  uint nblocks;      /// Number of data blocks
+  uint ninodes;      /// Number of inodes.
+  uint nlog;         /// Number of log blocks
+  uint logstart;     /// Block number of first log block
+  uint inodestart;   /// Block number of first inode block
+  uint bmapstart;    /// Block number of first free map block
 };
 
 #define NDIRECT 12
 #define NINDIRECT (BSIZE / sizeof(uint))
 #define MAXFILE (NDIRECT + NINDIRECT)
 
-// On-disk inode structure
+/// On-disk inode structure
 struct dinode {
-  short type;           // File type
-  short major;          // Major device number (T_DEV only)
-  short minor;          // Minor device number (T_DEV only)
-  short nlink;          // Number of links to inode in file system
-  uint size;            // Size of file (bytes)
-  uint addrs[NDIRECT+1];   // Data block addresses
+  short type;           /// File type
+  short major;          /// Major device number (T_DEV only)
+  short minor;          /// Minor device number (T_DEV only)
+  short nlink;          /// Number of links to inode in file system
+  uint size;            /// Size of file (bytes)
+  uint addrs[NDIRECT+1];   /// Data block addresses
 };
 
-// Inodes per block.
+/// Inodes per block.
 #define IPB           (BSIZE / sizeof(struct dinode))
 
-// Block containing inode i
+/// Block containing inode i
 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
 
-// Bitmap bits per block
+/// Bitmap bits per block
 #define BPB           (BSIZE*8)
 
-// Block of free map containing bit for block b
+/// Block of free map containing bit for block b
 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
 
-// Directory is a file containing a sequence of dirent structures.
+/// Directory is a file containing a sequence of dirent structures.
 #define DIRSIZ 14
 
 struct dirent {
diff --git a/gdbutil b/gdbutil
old mode 100644
new mode 100755
diff --git a/grep.c b/grep.c
old mode 100644
new mode 100755
index adc4835..948b503
--- a/grep.c
+++ b/grep.c
@@ -1,4 +1,4 @@
-// Simple grep.  Only supports ^ . * $ operators.
+/// Simple grep.  Only supports ^ . * $ operators.
 
 #include "types.h"
 #include "stat.h"
@@ -63,8 +63,8 @@ main(int argc, char *argv[])
   exit();
 }
 
-// Regexp matcher from Kernighan & Pike,
-// The Practice of Programming, Chapter 9.
+/// Regexp matcher from Kernighan & Pike,
+/// The Practice of Programming, Chapter 9.
 
 int matchhere(char*, char*);
 int matchstar(int, char*, char*);
@@ -74,14 +74,14 @@ match(char *re, char *text)
 {
   if(re[0] == '^')
     return matchhere(re+1, text);
-  do{  // must look at empty string
+  do{  /// must look at empty string
     if(matchhere(re, text))
       return 1;
   }while(*text++ != '\0');
   return 0;
 }
 
-// matchhere: search for re at beginning of text
+/// matchhere: search for re at beginning of text
 int matchhere(char *re, char *text)
 {
   if(re[0] == '\0')
@@ -95,10 +95,10 @@ int matchhere(char *re, char *text)
   return 0;
 }
 
-// matchstar: search for c*re at beginning of text
+/// matchstar: search for c*re at beginning of text
 int matchstar(int c, char *re, char *text)
 {
-  do{  // a * matches zero or more instances
+  do{  /// a * matches zero or more instances
     if(matchhere(re, text))
       return 1;
   }while(*text!='\0' && (*text++==c || c=='.'));
diff --git a/ide.c b/ide.c
old mode 100644
new mode 100755
index b4c0b1f..2e2a3fd
--- a/ide.c
+++ b/ide.c
@@ -1,4 +1,4 @@
-// Simple PIO-based (non-DMA) IDE driver code.
+/// Simple PIO-based (non-DMA) IDE driver code.
 
 #include "types.h"
 #include "defs.h"
@@ -24,9 +24,9 @@
 #define IDE_CMD_RDMUL 0xc4
 #define IDE_CMD_WRMUL 0xc5
 
-// idequeue points to the buf now being read/written to the disk.
-// idequeue->qnext points to the next buf to be processed.
-// You must hold idelock while manipulating queue.
+/// idequeue points to the buf now being read/written to the disk.
+/// idequeue->qnext points to the next buf to be processed.
+/// You must hold idelock while manipulating queue.
 
 static struct spinlock idelock;
 static struct buf *idequeue;
@@ -34,7 +34,7 @@ static struct buf *idequeue;
 static int havedisk1;
 static void idestart(struct buf*);
 
-// Wait for IDE disk to become ready.
+/// Wait for IDE disk to become ready.
 static int
 idewait(int checkerr)
 {
@@ -56,7 +56,7 @@ ideinit(void)
   ioapicenable(IRQ_IDE, ncpu - 1);
   idewait(0);
 
-  // Check if disk 1 is present
+  /// Check if disk 1 is present
   outb(0x1f6, 0xe0 | (1<<4));
   for(i=0; i<1000; i++){
     if(inb(0x1f7) != 0){
@@ -65,11 +65,11 @@ ideinit(void)
     }
   }
 
-  // Switch back to disk 0.
+  /// Switch back to disk 0.
   outb(0x1f6, 0xe0 | (0<<4));
 }
 
-// Start the request for b.  Caller must hold idelock.
+/// Start the request for b.  Caller must hold idelock.
 static void
 idestart(struct buf *b)
 {
@@ -85,8 +85,8 @@ idestart(struct buf *b)
   if (sector_per_block > 7) panic("idestart");
 
   idewait(0);
-  outb(0x3f6, 0);  // generate interrupt
-  outb(0x1f2, sector_per_block);  // number of sectors
+  outb(0x3f6, 0);  /// generate interrupt
+  outb(0x1f2, sector_per_block);  /// number of sectors
   outb(0x1f3, sector & 0xff);
   outb(0x1f4, (sector >> 8) & 0xff);
   outb(0x1f5, (sector >> 16) & 0xff);
@@ -99,13 +99,13 @@ idestart(struct buf *b)
   }
 }
 
-// Interrupt handler.
+/// Interrupt handler.
 void
 ideintr(void)
 {
   struct buf *b;
 
-  // First queued buffer is the active request.
+  /// First queued buffer is the active request.
   acquire(&idelock);
 
   if((b = idequeue) == 0){
@@ -114,26 +114,26 @@ ideintr(void)
   }
   idequeue = b->qnext;
 
-  // Read data if needed.
+  /// Read data if needed.
   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
     insl(0x1f0, b->data, BSIZE/4);
 
-  // Wake process waiting for this buf.
+  /// Wake process waiting for this buf.
   b->flags |= B_VALID;
   b->flags &= ~B_DIRTY;
   wakeup(b);
 
-  // Start disk on next buf in queue.
+  /// Start disk on next buf in queue.
   if(idequeue != 0)
     idestart(idequeue);
 
   release(&idelock);
 }
 
-//PAGEBREAK!
-// Sync buf with disk.
-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
-// Else if B_VALID is not set, read buf from disk, set B_VALID.
+///PAGEBREAK!
+/// Sync buf with disk.
+/// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+/// Else if B_VALID is not set, read buf from disk, set B_VALID.
 void
 iderw(struct buf *b)
 {
@@ -146,19 +146,19 @@ iderw(struct buf *b)
   if(b->dev != 0 && !havedisk1)
     panic("iderw: ide disk 1 not present");
 
-  acquire(&idelock);  //DOC:acquire-lock
+  acquire(&idelock);  ///DOC:acquire-lock
 
-  // Append b to idequeue.
+  /// Append b to idequeue.
   b->qnext = 0;
-  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  ///DOC:insert-queue
     ;
   *pp = b;
 
-  // Start disk if necessary.
+  /// Start disk if necessary.
   if(idequeue == b)
     idestart(b);
 
-  // Wait for request to finish.
+  /// Wait for request to finish.
   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
     sleep(b, &idelock);
   }
diff --git a/init.c b/init.c
old mode 100644
new mode 100755
index 046b551..1f095d4
--- a/init.c
+++ b/init.c
@@ -1,4 +1,4 @@
-// init: The initial user-level program
+/// init: The initial user-level program
 
 #include "types.h"
 #include "stat.h"
@@ -16,8 +16,8 @@ main(void)
     mknod("console", 1, 1);
     open("console", O_RDWR);
   }
-  dup(0);  // stdout
-  dup(0);  // stderr
+  dup(0);  /// stdout
+  dup(0);  /// stderr
 
   for(;;){
     printf(1, "init: starting sh\n");
diff --git a/initcode.S b/initcode.S
old mode 100644
new mode 100755
index 80ac5d8..de15ef0
--- a/initcode.S
+++ b/initcode.S
@@ -10,7 +10,7 @@
 start:
   pushl $argv
   pushl $init
-  pushl $0  // where caller pc would be
+  pushl $0  /// where caller pc would be
   movl $SYS_exec, %eax
   int $T_SYSCALL
 
diff --git a/ioapic.c b/ioapic.c
old mode 100644
new mode 100755
index cb0f015..56dcea3
--- a/ioapic.c
+++ b/ioapic.c
@@ -1,30 +1,30 @@
-// The I/O APIC manages hardware interrupts for an SMP system.
-// http://www.intel.com/design/chipsets/datashts/29056601.pdf
-// See also picirq.c.
+/// The I/O APIC manages hardware interrupts for an SMP system.
+/// http:///www.intel.com/design/chipsets/datashts/29056601.pdf
+/// See also picirq.c.
 
 #include "types.h"
 #include "defs.h"
 #include "traps.h"
 
-#define IOAPIC  0xFEC00000   // Default physical address of IO APIC
+#define IOAPIC  0xFEC00000   /// Default physical address of IO APIC
 
-#define REG_ID     0x00  // Register index: ID
-#define REG_VER    0x01  // Register index: version
-#define REG_TABLE  0x10  // Redirection table base
+#define REG_ID     0x00  /// Register index: ID
+#define REG_VER    0x01  /// Register index: version
+#define REG_TABLE  0x10  /// Redirection table base
 
-// The redirection table starts at REG_TABLE and uses
-// two registers to configure each interrupt.
-// The first (low) register in a pair contains configuration bits.
-// The second (high) register contains a bitmask telling which
-// CPUs can serve that interrupt.
-#define INT_DISABLED   0x00010000  // Interrupt disabled
-#define INT_LEVEL      0x00008000  // Level-triggered (vs edge-)
-#define INT_ACTIVELOW  0x00002000  // Active low (vs high)
-#define INT_LOGICAL    0x00000800  // Destination is CPU id (vs APIC ID)
+/// The redirection table starts at REG_TABLE and uses
+/// two registers to configure each interrupt.
+/// The first (low) register in a pair contains configuration bits.
+/// The second (high) register contains a bitmask telling which
+/// CPUs can serve that interrupt.
+#define INT_DISABLED   0x00010000  /// Interrupt disabled
+#define INT_LEVEL      0x00008000  /// Level-triggered (vs edge-)
+#define INT_ACTIVELOW  0x00002000  /// Active low (vs high)
+#define INT_LOGICAL    0x00000800  /// Destination is CPU id (vs APIC ID)
 
 volatile struct ioapic *ioapic;
 
-// IO APIC MMIO structure: write reg, then read or write data.
+/// IO APIC MMIO structure: write reg, then read or write data.
 struct ioapic {
   uint reg;
   uint pad[3];
@@ -56,8 +56,8 @@ ioapicinit(void)
   if(id != ioapicid)
     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
 
-  // Mark all interrupts edge-triggered, active high, disabled,
-  // and not routed to any CPUs.
+  /// Mark all interrupts edge-triggered, active high, disabled,
+  /// and not routed to any CPUs.
   for(i = 0; i <= maxintr; i++){
     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
     ioapicwrite(REG_TABLE+2*i+1, 0);
@@ -67,9 +67,9 @@ ioapicinit(void)
 void
 ioapicenable(int irq, int cpunum)
 {
-  // Mark interrupt edge-triggered, active high,
-  // enabled, and routed to the given cpunum,
-  // which happens to be that cpu's APIC ID.
+  /// Mark interrupt edge-triggered, active high,
+  /// enabled, and routed to the given cpunum,
+  /// which happens to be that cpu's APIC ID.
   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
 }
diff --git a/kalloc.c b/kalloc.c
old mode 100644
new mode 100755
index 14cd4f4..59e0bd9
--- a/kalloc.c
+++ b/kalloc.c
@@ -1,6 +1,6 @@
-// Physical memory allocator, intended to allocate
-// memory for user processes, kernel stacks, page table pages,
-// and pipe buffers. Allocates 4096-byte pages.
+/// Physical memory allocator, intended to allocate
+/// memory for user processes, kernel stacks, page table pages,
+/// and pipe buffers. Allocates 4096-byte pages.
 
 #include "types.h"
 #include "defs.h"
@@ -10,8 +10,8 @@
 #include "spinlock.h"
 
 void freerange(void *vstart, void *vend);
-extern char end[]; // first address after kernel loaded from ELF file
-                   // defined by the kernel linker script in kernel.ld
+extern char end[]; /// first address after kernel loaded from ELF file
+                   /// defined by the kernel linker script in kernel.ld
 
 struct run {
   struct run *next;
@@ -23,11 +23,11 @@ struct {
   struct run *freelist;
 } kmem;
 
-// Initialization happens in two phases.
-// 1. main() calls kinit1() while still using entrypgdir to place just
-// the pages mapped by entrypgdir on free list.
-// 2. main() calls kinit2() with the rest of the physical pages
-// after installing a full page table that maps them on all cores.
+/// Initialization happens in two phases.
+/// 1. main() calls kinit1() while still using entrypgdir to place just
+/// the pages mapped by entrypgdir on free list.
+/// 2. main() calls kinit2() with the rest of the physical pages
+/// after installing a full page table that maps them on all cores.
 void
 kinit1(void *vstart, void *vend)
 {
@@ -51,11 +51,11 @@ freerange(void *vstart, void *vend)
   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
     kfree(p);
 }
-//PAGEBREAK: 21
-// Free the page of physical memory pointed at by v,
-// which normally should have been returned by a
-// call to kalloc().  (The exception is when
-// initializing the allocator; see kinit above.)
+///PAGEBREAK: 21
+/// Free the page of physical memory pointed at by v,
+/// which normally should have been returned by a
+/// call to kalloc().  (The exception is when
+/// initializing the allocator; see kinit above.)
 void
 kfree(char *v)
 {
@@ -64,7 +64,7 @@ kfree(char *v)
   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
     panic("kfree");
 
-  // Fill with junk to catch dangling refs.
+  /// Fill with junk to catch dangling refs.
   memset(v, 1, PGSIZE);
 
   if(kmem.use_lock)
@@ -76,9 +76,9 @@ kfree(char *v)
     release(&kmem.lock);
 }
 
-// Allocate one 4096-byte page of physical memory.
-// Returns a pointer that the kernel can use.
-// Returns 0 if the memory cannot be allocated.
+/// Allocate one 4096-byte page of physical memory.
+/// Returns a pointer that the kernel can use.
+/// Returns 0 if the memory cannot be allocated.
 char*
 kalloc(void)
 {
diff --git a/kbd.c b/kbd.c
old mode 100644
new mode 100755
index 32c1463..041466b
--- a/kbd.c
+++ b/kbd.c
@@ -21,12 +21,12 @@ kbdgetc(void)
     shift |= E0ESC;
     return 0;
   } else if(data & 0x80){
-    // Key released
+    /// Key released
     data = (shift & E0ESC ? data : data & 0x7F);
     shift &= ~(shiftcode[data] | E0ESC);
     return 0;
   } else if(shift & E0ESC){
-    // Last character was an E0 escape; or with 0x80
+    /// Last character was an E0 escape; or with 0x80
     data |= 0x80;
     shift &= ~E0ESC;
   }
diff --git a/kbd.h b/kbd.h
old mode 100644
new mode 100755
index babbd6e..1f5a5f1
--- a/kbd.h
+++ b/kbd.h
@@ -1,8 +1,8 @@
-// PC keyboard interface constants
+/// PC keyboard interface constants
 
-#define KBSTATP         0x64    // kbd controller status port(I)
-#define KBS_DIB         0x01    // kbd data in buffer
-#define KBDATAP         0x60    // kbd data port(I)
+#define KBSTATP         0x64    /// kbd controller status port(I)
+#define KBS_DIB         0x01    /// kbd data in buffer
+#define KBDATAP         0x60    /// kbd data port(I)
 
 #define NO              0
 
@@ -16,7 +16,7 @@
 
 #define E0ESC           (1<<6)
 
-// Special keycodes
+/// Special keycodes
 #define KEY_HOME        0xE0
 #define KEY_END         0xE1
 #define KEY_UP          0xE2
@@ -28,7 +28,7 @@
 #define KEY_INS         0xE8
 #define KEY_DEL         0xE9
 
-// C('A') == Control-A
+/// C('A') == Control-A
 #define C(x) (x - '@')
 
 static uchar shiftcode[256] =
@@ -50,19 +50,19 @@ static uchar togglecode[256] =
 
 static uchar normalmap[256] =
 {
-  NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
+  NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  /// 0x00
   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
-  'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
+  'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  /// 0x10
   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
-  'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
+  'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  /// 0x20
   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
-  'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
+  'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  /// 0x30
   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  /// 0x40
   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
-  [0x9C] '\n',      // KP_Enter
-  [0xB5] '/',       // KP_Div
+  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   /// 0x50
+  [0x9C] '\n',      /// KP_Enter
+  [0xB5] '/',       /// KP_Div
   [0xC8] KEY_UP,    [0xD0] KEY_DN,
   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
   [0xCB] KEY_LF,    [0xCD] KEY_RT,
@@ -72,19 +72,19 @@ static uchar normalmap[256] =
 
 static uchar shiftmap[256] =
 {
-  NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
+  NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  /// 0x00
   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
-  'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
+  'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  /// 0x10
   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
-  'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
+  'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  /// 0x20
   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
-  'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
+  'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  /// 0x30
   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  /// 0x40
   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
-  [0x9C] '\n',      // KP_Enter
-  [0xB5] '/',       // KP_Div
+  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   /// 0x50
+  [0x9C] '\n',      /// KP_Enter
+  [0xB5] '/',       /// KP_Div
   [0xC8] KEY_UP,    [0xD0] KEY_DN,
   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
   [0xCB] KEY_LF,    [0xCD] KEY_RT,
@@ -101,8 +101,8 @@ static uchar ctlmap[256] =
   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
-  [0x9C] '\r',      // KP_Enter
-  [0xB5] C('/'),    // KP_Div
+  [0x9C] '\r',      /// KP_Enter
+  [0xB5] C('/'),    /// KP_Div
   [0xC8] KEY_UP,    [0xD0] KEY_DN,
   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
   [0xCB] KEY_LF,    [0xCD] KEY_RT,
diff --git a/kernel.ld b/kernel.ld
old mode 100644
new mode 100755
diff --git a/kill.c b/kill.c
old mode 100644
new mode 100755
diff --git a/lapic.c b/lapic.c
old mode 100644
new mode 100755
index b22bbd7..72a45a1
--- a/lapic.c
+++ b/lapic.c
@@ -1,5 +1,5 @@
-// The local APIC manages internal (non-I/O) interrupts.
-// See Chapter 8 & Appendix C of Intel processor manual volume 3.
+/// The local APIC manages internal (non-I/O) interrupts.
+/// See Chapter 8 & Appendix C of Intel processor manual volume 3.
 
 #include "param.h"
 #include "types.h"
@@ -10,45 +10,45 @@
 #include "mmu.h"
 #include "x86.h"
 
-// Local APIC registers, divided by 4 for use as uint[] indices.
-#define ID      (0x0020/4)   // ID
-#define VER     (0x0030/4)   // Version
-#define TPR     (0x0080/4)   // Task Priority
-#define EOI     (0x00B0/4)   // EOI
-#define SVR     (0x00F0/4)   // Spurious Interrupt Vector
-  #define ENABLE     0x00000100   // Unit Enable
-#define ESR     (0x0280/4)   // Error Status
-#define ICRLO   (0x0300/4)   // Interrupt Command
-  #define INIT       0x00000500   // INIT/RESET
-  #define STARTUP    0x00000600   // Startup IPI
-  #define DELIVS     0x00001000   // Delivery status
-  #define ASSERT     0x00004000   // Assert interrupt (vs deassert)
+/// Local APIC registers, divided by 4 for use as uint[] indices.
+#define ID      (0x0020/4)   /// ID
+#define VER     (0x0030/4)   /// Version
+#define TPR     (0x0080/4)   /// Task Priority
+#define EOI     (0x00B0/4)   /// EOI
+#define SVR     (0x00F0/4)   /// Spurious Interrupt Vector
+  #define ENABLE     0x00000100   /// Unit Enable
+#define ESR     (0x0280/4)   /// Error Status
+#define ICRLO   (0x0300/4)   /// Interrupt Command
+  #define INIT       0x00000500   /// INIT/RESET
+  #define STARTUP    0x00000600   /// Startup IPI
+  #define DELIVS     0x00001000   /// Delivery status
+  #define ASSERT     0x00004000   /// Assert interrupt (vs deassert)
   #define DEASSERT   0x00000000
-  #define LEVEL      0x00008000   // Level triggered
-  #define BCAST      0x00080000   // Send to all APICs, including self.
+  #define LEVEL      0x00008000   /// Level triggered
+  #define BCAST      0x00080000   /// Send to all APICs, including self.
   #define BUSY       0x00001000
   #define FIXED      0x00000000
-#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]
-#define TIMER   (0x0320/4)   // Local Vector Table 0 (TIMER)
-  #define X1         0x0000000B   // divide counts by 1
-  #define PERIODIC   0x00020000   // Periodic
-#define PCINT   (0x0340/4)   // Performance Counter LVT
-#define LINT0   (0x0350/4)   // Local Vector Table 1 (LINT0)
-#define LINT1   (0x0360/4)   // Local Vector Table 2 (LINT1)
-#define ERROR   (0x0370/4)   // Local Vector Table 3 (ERROR)
-  #define MASKED     0x00010000   // Interrupt masked
-#define TICR    (0x0380/4)   // Timer Initial Count
-#define TCCR    (0x0390/4)   // Timer Current Count
-#define TDCR    (0x03E0/4)   // Timer Divide Configuration
-
-volatile uint *lapic;  // Initialized in mp.c
-
-//PAGEBREAK!
+#define ICRHI   (0x0310/4)   /// Interrupt Command [63:32]
+#define TIMER   (0x0320/4)   /// Local Vector Table 0 (TIMER)
+  #define X1         0x0000000B   /// divide counts by 1
+  #define PERIODIC   0x00020000   /// Periodic
+#define PCINT   (0x0340/4)   /// Performance Counter LVT
+#define LINT0   (0x0350/4)   /// Local Vector Table 1 (LINT0)
+#define LINT1   (0x0360/4)   /// Local Vector Table 2 (LINT1)
+#define ERROR   (0x0370/4)   /// Local Vector Table 3 (ERROR)
+  #define MASKED     0x00010000   /// Interrupt masked
+#define TICR    (0x0380/4)   /// Timer Initial Count
+#define TCCR    (0x0390/4)   /// Timer Current Count
+#define TDCR    (0x03E0/4)   /// Timer Divide Configuration
+
+volatile uint *lapic;  /// Initialized in mp.c
+
+///PAGEBREAK!
 static void
 lapicw(int index, int value)
 {
   lapic[index] = value;
-  lapic[ID];  // wait for write to finish, by reading
+  lapic[ID];  /// wait for write to finish, by reading
 }
 
 void
@@ -57,43 +57,43 @@ lapicinit(void)
   if(!lapic)
     return;
 
-  // Enable local APIC; set spurious interrupt vector.
+  /// Enable local APIC; set spurious interrupt vector.
   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
 
-  // The timer repeatedly counts down at bus frequency
-  // from lapic[TICR] and then issues an interrupt.
-  // If xv6 cared more about precise timekeeping,
-  // TICR would be calibrated using an external time source.
+  /// The timer repeatedly counts down at bus frequency
+  /// from lapic[TICR] and then issues an interrupt.
+  /// If xv6 cared more about precise timekeeping,
+  /// TICR would be calibrated using an external time source.
   lapicw(TDCR, X1);
   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
   lapicw(TICR, 10000000);
 
-  // Disable logical interrupt lines.
+  /// Disable logical interrupt lines.
   lapicw(LINT0, MASKED);
   lapicw(LINT1, MASKED);
 
-  // Disable performance counter overflow interrupts
-  // on machines that provide that interrupt entry.
+  /// Disable performance counter overflow interrupts
+  /// on machines that provide that interrupt entry.
   if(((lapic[VER]>>16) & 0xFF) >= 4)
     lapicw(PCINT, MASKED);
 
-  // Map error interrupt to IRQ_ERROR.
+  /// Map error interrupt to IRQ_ERROR.
   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
 
-  // Clear error status register (requires back-to-back writes).
+  /// Clear error status register (requires back-to-back writes).
   lapicw(ESR, 0);
   lapicw(ESR, 0);
 
-  // Ack any outstanding interrupts.
+  /// Ack any outstanding interrupts.
   lapicw(EOI, 0);
 
-  // Send an Init Level De-Assert to synchronise arbitration ID's.
+  /// Send an Init Level De-Assert to synchronise arbitration ID's.
   lapicw(ICRHI, 0);
   lapicw(ICRLO, BCAST | INIT | LEVEL);
   while(lapic[ICRLO] & DELIVS)
     ;
 
-  // Enable interrupts on the APIC (but not on the processor).
+  /// Enable interrupts on the APIC (but not on the processor).
   lapicw(TPR, 0);
 }
 
@@ -105,7 +105,7 @@ lapicid(void)
   return lapic[ID] >> 24;
 }
 
-// Acknowledge interrupt.
+/// Acknowledge interrupt.
 void
 lapiceoi(void)
 {
@@ -113,8 +113,8 @@ lapiceoi(void)
     lapicw(EOI, 0);
 }
 
-// Spin for a given number of microseconds.
-// On real hardware would want to tune this dynamically.
+/// Spin for a given number of microseconds.
+/// On real hardware would want to tune this dynamically.
 void
 microdelay(int us)
 {
@@ -123,36 +123,36 @@ microdelay(int us)
 #define CMOS_PORT    0x70
 #define CMOS_RETURN  0x71
 
-// Start additional processor running entry code at addr.
-// See Appendix B of MultiProcessor Specification.
+/// Start additional processor running entry code at addr.
+/// See Appendix B of MultiProcessor Specification.
 void
 lapicstartap(uchar apicid, uint addr)
 {
   int i;
   ushort *wrv;
 
-  // "The BSP must initialize CMOS shutdown code to 0AH
-  // and the warm reset vector (DWORD based at 40:67) to point at
-  // the AP startup code prior to the [universal startup algorithm]."
-  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
+  /// "The BSP must initialize CMOS shutdown code to 0AH
+  /// and the warm reset vector (DWORD based at 40:67) to point at
+  /// the AP startup code prior to the [universal startup algorithm]."
+  outb(CMOS_PORT, 0xF);  /// offset 0xF is shutdown code
   outb(CMOS_PORT+1, 0x0A);
-  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
+  wrv = (ushort*)P2V((0x40<<4 | 0x67));  /// Warm reset vector
   wrv[0] = 0;
   wrv[1] = addr >> 4;
 
-  // "Universal startup algorithm."
-  // Send INIT (level-triggered) interrupt to reset other CPU.
+  /// "Universal startup algorithm."
+  /// Send INIT (level-triggered) interrupt to reset other CPU.
   lapicw(ICRHI, apicid<<24);
   lapicw(ICRLO, INIT | LEVEL | ASSERT);
   microdelay(200);
   lapicw(ICRLO, INIT | LEVEL);
-  microdelay(100);    // should be 10ms, but too slow in Bochs!
+  microdelay(100);    /// should be 10ms, but too slow in Bochs!
 
-  // Send startup IPI (twice!) to enter code.
-  // Regular hardware is supposed to only accept a STARTUP
-  // when it is in the halted state due to an INIT.  So the second
-  // should be ignored, but it is part of the official Intel algorithm.
-  // Bochs complains about the second one.  Too bad for Bochs.
+  /// Send startup IPI (twice!) to enter code.
+  /// Regular hardware is supposed to only accept a STARTUP
+  /// when it is in the halted state due to an INIT.  So the second
+  /// should be ignored, but it is part of the official Intel algorithm.
+  /// Bochs complains about the second one.  Too bad for Bochs.
   for(i = 0; i < 2; i++){
     lapicw(ICRHI, apicid<<24);
     lapicw(ICRLO, STARTUP | (addr>>12));
@@ -162,7 +162,7 @@ lapicstartap(uchar apicid, uint addr)
 
 #define CMOS_STATA   0x0a
 #define CMOS_STATB   0x0b
-#define CMOS_UIP    (1 << 7)        // RTC update in progress
+#define CMOS_UIP    (1 << 7)        /// RTC update in progress
 
 #define SECS    0x00
 #define MINS    0x02
@@ -191,7 +191,7 @@ fill_rtcdate(struct rtcdate *r)
   r->year   = cmos_read(YEAR);
 }
 
-// qemu seems to use 24-hour GWT and the values are BCD encoded
+/// qemu seems to use 24-hour GWT and the values are BCD encoded
 void
 cmostime(struct rtcdate *r)
 {
@@ -202,7 +202,7 @@ cmostime(struct rtcdate *r)
 
   bcd = (sb & (1 << 2)) == 0;
 
-  // make sure CMOS doesn't modify time while we read it
+  /// make sure CMOS doesn't modify time while we read it
   for(;;) {
     fill_rtcdate(&t1);
     if(cmos_read(CMOS_STATA) & CMOS_UIP)
@@ -212,7 +212,7 @@ cmostime(struct rtcdate *r)
       break;
   }
 
-  // convert
+  /// convert
   if(bcd) {
 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
     CONV(second);
diff --git a/ln.c b/ln.c
old mode 100644
new mode 100755
diff --git a/log.c b/log.c
old mode 100644
new mode 100755
index a64c0f6..b7b383b
--- a/log.c
+++ b/log.c
@@ -6,31 +6,31 @@
 #include "fs.h"
 #include "buf.h"
 
-// Simple logging that allows concurrent FS system calls.
-//
-// A log transaction contains the updates of multiple FS system
-// calls. The logging system only commits when there are
-// no FS system calls active. Thus there is never
-// any reasoning required about whether a commit might
-// write an uncommitted system call's updates to disk.
-//
-// A system call should call begin_op()/end_op() to mark
-// its start and end. Usually begin_op() just increments
-// the count of in-progress FS system calls and returns.
-// But if it thinks the log is close to running out, it
-// sleeps until the last outstanding end_op() commits.
-//
-// The log is a physical re-do log containing disk blocks.
-// The on-disk log format:
-//   header block, containing block #s for block A, B, C, ...
-//   block A
-//   block B
-//   block C
-//   ...
-// Log appends are synchronous.
-
-// Contents of the header block, used for both the on-disk header block
-// and to keep track in memory of logged block# before commit.
+/// Simple logging that allows concurrent FS system calls.
+///
+/// A log transaction contains the updates of multiple FS system
+/// calls. The logging system only commits when there are
+/// no FS system calls active. Thus there is never
+/// any reasoning required about whether a commit might
+/// write an uncommitted system call's updates to disk.
+///
+/// A system call should call begin_op()/end_op() to mark
+/// its start and end. Usually begin_op() just increments
+/// the count of in-progress FS system calls and returns.
+/// But if it thinks the log is close to running out, it
+/// sleeps until the last outstanding end_op() commits.
+///
+/// The log is a physical re-do log containing disk blocks.
+/// The on-disk log format:
+///   header block, containing block #s for block A, B, C, ...
+///   block A
+///   block B
+///   block C
+///   ...
+/// Log appends are synchronous.
+
+/// Contents of the header block, used for both the on-disk header block
+/// and to keep track in memory of logged block# before commit.
 struct logheader {
   int n;
   int block[LOGSIZE];
@@ -40,8 +40,8 @@ struct log {
   struct spinlock lock;
   int start;
   int size;
-  int outstanding; // how many FS sys calls are executing.
-  int committing;  // in commit(), please wait.
+  int outstanding; /// how many FS sys calls are executing.
+  int committing;  /// in commit(), please wait.
   int dev;
   struct logheader lh;
 };
@@ -65,23 +65,23 @@ initlog(int dev)
   recover_from_log();
 }
 
-// Copy committed blocks from log to their home location
+/// Copy committed blocks from log to their home location
 static void
 install_trans(void)
 {
   int tail;
 
   for (tail = 0; tail < log.lh.n; tail++) {
-    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
-    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
-    bwrite(dbuf);  // write dst to disk
+    struct buf *lbuf = bread(log.dev, log.start+tail+1); /// read log block
+    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); /// read dst
+    memmove(dbuf->data, lbuf->data, BSIZE);  /// copy block to dst
+    bwrite(dbuf);  /// write dst to disk
     brelse(lbuf);
     brelse(dbuf);
   }
 }
 
-// Read the log header from disk into the in-memory log header
+/// Read the log header from disk into the in-memory log header
 static void
 read_head(void)
 {
@@ -95,9 +95,9 @@ read_head(void)
   brelse(buf);
 }
 
-// Write in-memory log header to disk.
-// This is the true point at which the
-// current transaction commits.
+/// Write in-memory log header to disk.
+/// This is the true point at which the
+/// current transaction commits.
 static void
 write_head(void)
 {
@@ -116,12 +116,12 @@ static void
 recover_from_log(void)
 {
   read_head();
-  install_trans(); // if committed, copy from log to disk
+  install_trans(); /// if committed, copy from log to disk
   log.lh.n = 0;
-  write_head(); // clear the log
+  write_head(); /// clear the log
 }
 
-// called at the start of each FS system call.
+/// called at the start of each FS system call.
 void
 begin_op(void)
 {
@@ -130,7 +130,7 @@ begin_op(void)
     if(log.committing){
       sleep(&log, &log.lock);
     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
-      // this op might exhaust log space; wait for commit.
+      /// this op might exhaust log space; wait for commit.
       sleep(&log, &log.lock);
     } else {
       log.outstanding += 1;
@@ -140,8 +140,8 @@ begin_op(void)
   }
 }
 
-// called at the end of each FS system call.
-// commits if this was the last outstanding operation.
+/// called at the end of each FS system call.
+/// commits if this was the last outstanding operation.
 void
 end_op(void)
 {
@@ -155,16 +155,16 @@ end_op(void)
     do_commit = 1;
     log.committing = 1;
   } else {
-    // begin_op() may be waiting for log space,
-    // and decrementing log.outstanding has decreased
-    // the amount of reserved space.
+    /// begin_op() may be waiting for log space,
+    /// and decrementing log.outstanding has decreased
+    /// the amount of reserved space.
     wakeup(&log);
   }
   release(&log.lock);
 
   if(do_commit){
-    // call commit w/o holding locks, since not allowed
-    // to sleep with locks.
+    /// call commit w/o holding locks, since not allowed
+    /// to sleep with locks.
     commit();
     acquire(&log.lock);
     log.committing = 0;
@@ -173,17 +173,17 @@ end_op(void)
   }
 }
 
-// Copy modified blocks from cache to log.
+/// Copy modified blocks from cache to log.
 static void
 write_log(void)
 {
   int tail;
 
   for (tail = 0; tail < log.lh.n; tail++) {
-    struct buf *to = bread(log.dev, log.start+tail+1); // log block
-    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+    struct buf *to = bread(log.dev, log.start+tail+1); /// log block
+    struct buf *from = bread(log.dev, log.lh.block[tail]); /// cache block
     memmove(to->data, from->data, BSIZE);
-    bwrite(to);  // write the log
+    bwrite(to);  /// write the log
     brelse(from);
     brelse(to);
   }
@@ -193,23 +193,23 @@ static void
 commit()
 {
   if (log.lh.n > 0) {
-    write_log();     // Write modified blocks from cache to log
-    write_head();    // Write header to disk -- the real commit
-    install_trans(); // Now install writes to home locations
+    write_log();     /// Write modified blocks from cache to log
+    write_head();    /// Write header to disk -- the real commit
+    install_trans(); /// Now install writes to home locations
     log.lh.n = 0;
-    write_head();    // Erase the transaction from the log
+    write_head();    /// Erase the transaction from the log
   }
 }
 
-// Caller has modified b->data and is done with the buffer.
-// Record the block number and pin in the cache with B_DIRTY.
-// commit()/write_log() will do the disk write.
-//
-// log_write() replaces bwrite(); a typical use is:
-//   bp = bread(...)
-//   modify bp->data[]
-//   log_write(bp)
-//   brelse(bp)
+/// Caller has modified b->data and is done with the buffer.
+/// Record the block number and pin in the cache with B_DIRTY.
+/// commit()/write_log() will do the disk write.
+///
+/// log_write() replaces bwrite(); a typical use is:
+///   bp = bread(...)
+///   modify bp->data[]
+///   log_write(bp)
+///   brelse(bp)
 void
 log_write(struct buf *b)
 {
@@ -222,13 +222,13 @@ log_write(struct buf *b)
 
   acquire(&log.lock);
   for (i = 0; i < log.lh.n; i++) {
-    if (log.lh.block[i] == b->blockno)   // log absorbtion
+    if (log.lh.block[i] == b->blockno)   /// log absorbtion
       break;
   }
   log.lh.block[i] = b->blockno;
   if (i == log.lh.n)
     log.lh.n++;
-  b->flags |= B_DIRTY; // prevent eviction
+  b->flags |= B_DIRTY; /// prevent eviction
   release(&log.lock);
 }
 
diff --git a/ls.c b/ls.c
old mode 100644
new mode 100755
index 2862913..4844997
--- a/ls.c
+++ b/ls.c
@@ -9,12 +9,12 @@ fmtname(char *path)
   static char buf[DIRSIZ+1];
   char *p;
 
-  // Find first character after last slash.
+  /// Find first character after last slash.
   for(p=path+strlen(path); p >= path && *p != '/'; p--)
     ;
   p++;
 
-  // Return blank-padded name.
+  /// Return blank-padded name.
   if(strlen(p) >= DIRSIZ)
     return p;
   memmove(buf, p, strlen(p));
diff --git a/main.c b/main.c
old mode 100644
new mode 100755
index 9924e64..c4de9cd
--- a/main.c
+++ b/main.c
@@ -4,40 +4,42 @@
 #include "memlayout.h"
 #include "mmu.h"
 #include "proc.h"
+#include "sock.h"
 #include "x86.h"
 
 static void startothers(void);
 static void mpmain(void)  __attribute__((noreturn));
 extern pde_t *kpgdir;
-extern char end[]; // first address after kernel loaded from ELF file
+extern char end[]; /// first address after kernel loaded from ELF file
 
-// Bootstrap processor starts running C code here.
-// Allocate a real stack and switch to it, first
-// doing some setup required for memory allocator to work.
+/// Bootstrap processor starts running C code here.
+/// Allocate a real stack and switch to it, first
+/// doing some setup required for memory allocator to work.
 int
 main(void)
 {
-  kinit1(end, P2V(4*1024*1024)); // phys page allocator
-  kvmalloc();      // kernel page table
-  mpinit();        // detect other processors
-  lapicinit();     // interrupt controller
-  seginit();       // segment descriptors
-  picinit();       // disable pic
-  ioapicinit();    // another interrupt controller
-  consoleinit();   // console hardware
-  uartinit();      // serial port
-  pinit();         // process table
-  tvinit();        // trap vectors
-  binit();         // buffer cache
-  fileinit();      // file table
-  ideinit();       // disk 
-  startothers();   // start other processors
-  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
-  userinit();      // first user process
-  mpmain();        // finish this processor's setup
+  kinit1(end, P2V(4*1024*1024)); /// phys page allocator
+  kvmalloc();      /// kernel page table
+  mpinit();        /// detect other processors
+  lapicinit();     /// interrupt controller
+  seginit();       /// segment descriptors
+  picinit();       /// disable pic
+  ioapicinit();    /// another interrupt controller
+  consoleinit();   /// console hardware
+  uartinit();      /// serial port
+  pinit();         /// process table
+  sinit();         /// socket table
+  tvinit();        /// trap vectors
+  binit();         /// buffer cache
+  fileinit();      /// file table
+  ideinit();       /// disk
+  startothers();   /// start other processors
+  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); /// must come after startothers()
+  userinit();      /// first user process
+  mpmain();        /// finish this processor's setup
 }
 
-// Other CPUs jump here from entryother.S.
+/// Other CPUs jump here from entryother.S.
 static void
 mpenter(void)
 {
@@ -47,19 +49,19 @@ mpenter(void)
   mpmain();
 }
 
-// Common CPU setup code.
+/// Common CPU setup code.
 static void
 mpmain(void)
 {
   cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
-  idtinit();       // load idt register
-  xchg(&(mycpu()->started), 1); // tell startothers() we're up
-  scheduler();     // start running processes
+  idtinit();       /// load idt register
+  xchg(&(mycpu()->started), 1); /// tell startothers() we're up
+  scheduler();     /// start running processes
 }
 
-pde_t entrypgdir[];  // For entry.S
+pde_t entrypgdir[];  /// For entry.S
 
-// Start the non-boot (AP) processors.
+/// Start the non-boot (AP) processors.
 static void
 startothers(void)
 {
@@ -68,19 +70,19 @@ startothers(void)
   struct cpu *c;
   char *stack;
 
-  // Write entry code to unused memory at 0x7000.
-  // The linker has placed the image of entryother.S in
-  // _binary_entryother_start.
+  /// Write entry code to unused memory at 0x7000.
+  /// The linker has placed the image of entryother.S in
+  /// _binary_entryother_start.
   code = P2V(0x7000);
   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
 
   for(c = cpus; c < cpus+ncpu; c++){
-    if(c == mycpu())  // We've started already.
+    if(c == mycpu())  /// We've started already.
       continue;
 
-    // Tell entryother.S what stack to use, where to enter, and what
-    // pgdir to use. We cannot use kpgdir yet, because the AP processor
-    // is running in low  memory, so we use entrypgdir for the APs too.
+    /// Tell entryother.S what stack to use, where to enter, and what
+    /// pgdir to use. We cannot use kpgdir yet, because the AP processor
+    /// is running in low  memory, so we use entrypgdir for the APs too.
     stack = kalloc();
     *(void**)(code-4) = stack + KSTACKSIZE;
     *(void(**)(void))(code-8) = mpenter;
@@ -88,29 +90,29 @@ startothers(void)
 
     lapicstartap(c->apicid, V2P(code));
 
-    // wait for cpu to finish mpmain()
+    /// wait for cpu to finish mpmain()
     while(c->started == 0)
       ;
   }
 }
 
-// The boot page table used in entry.S and entryother.S.
-// Page directories (and page tables) must start on page boundaries,
-// hence the __aligned__ attribute.
-// PTE_PS in a page directory entry enables 4Mbyte pages.
+/// The boot page table used in entry.S and entryother.S.
+/// Page directories (and page tables) must start on page boundaries,
+/// hence the __aligned__ attribute.
+/// PTE_PS in a page directory entry enables 4Mbyte pages.
 
 __attribute__((__aligned__(PGSIZE)))
 pde_t entrypgdir[NPDENTRIES] = {
-  // Map VA's [0, 4MB) to PA's [0, 4MB)
+  /// Map VA's [0, 4MB) to PA's [0, 4MB)
   [0] = (0) | PTE_P | PTE_W | PTE_PS,
-  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
+  /// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
 };
 
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
+///PAGEBREAK!
+/// Blank page.
+///PAGEBREAK!
+/// Blank page.
+///PAGEBREAK!
+/// Blank page.
 
diff --git a/memide.c b/memide.c
old mode 100644
new mode 100755
index ba267ac..66abcee
--- a/memide.c
+++ b/memide.c
@@ -1,5 +1,5 @@
-// Fake IDE disk; stores blocks in memory.
-// Useful for running kernel without scratch disk.
+/// Fake IDE disk; stores blocks in memory.
+/// Useful for running kernel without scratch disk.
 
 #include "types.h"
 #include "defs.h"
@@ -25,16 +25,16 @@ ideinit(void)
   disksize = (uint)_binary_fs_img_size/BSIZE;
 }
 
-// Interrupt handler.
+/// Interrupt handler.
 void
 ideintr(void)
 {
-  // no-op
+  /// no-op
 }
 
-// Sync buf with disk.
-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
-// Else if B_VALID is not set, read buf from disk, set B_VALID.
+/// Sync buf with disk.
+/// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+/// Else if B_VALID is not set, read buf from disk, set B_VALID.
 void
 iderw(struct buf *b)
 {
diff --git a/memlayout.h b/memlayout.h
old mode 100644
new mode 100755
index d1615f7..e2ef372
--- a/memlayout.h
+++ b/memlayout.h
@@ -1,15 +1,15 @@
-// Memory layout
+/// Memory layout
 
-#define EXTMEM  0x100000            // Start of extended memory
-#define PHYSTOP 0xE000000           // Top physical memory
-#define DEVSPACE 0xFE000000         // Other devices are at high addresses
+#define EXTMEM  0x100000            /// Start of extended memory
+#define PHYSTOP 0xE000000           /// Top physical memory
+#define DEVSPACE 0xFE000000         /// Other devices are at high addresses
 
-// Key addresses for address space layout (see kmap in vm.c for layout)
-#define KERNBASE 0x80000000         // First kernel virtual address
-#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
+/// Key addresses for address space layout (see kmap in vm.c for layout)
+#define KERNBASE 0x80000000         /// First kernel virtual address
+#define KERNLINK (KERNBASE+EXTMEM)  /// Address where kernel is linked
 
 #define V2P(a) (((uint) (a)) - KERNBASE)
 #define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
 
-#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
-#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
+#define V2P_WO(x) ((x) - KERNBASE)    /// same as V2P, but without casts
+#define P2V_WO(x) ((x) + KERNBASE)    /// same as P2V, but without casts
diff --git a/mkdir.c b/mkdir.c
old mode 100644
new mode 100755
diff --git a/mkfs.c b/mkfs.c
old mode 100644
new mode 100755
index 8e011a7..d43ff65
--- a/mkfs.c
+++ b/mkfs.c
@@ -5,7 +5,7 @@
 #include <fcntl.h>
 #include <assert.h>
 
-#define stat xv6_stat  // avoid clash with host struct stat
+#define stat xv6_stat  /// avoid clash with host struct stat
 #include "types.h"
 #include "fs.h"
 #include "stat.h"
@@ -17,14 +17,14 @@
 
 #define NINODES 200
 
-// Disk layout:
-// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
+/// Disk layout:
+/// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
 
 int nbitmap = FSSIZE/(BSIZE*8) + 1;
 int ninodeblocks = NINODES / IPB + 1;
 int nlog = LOGSIZE;
-int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
-int nblocks;  // Number of data blocks
+int nmeta;    /// Number of meta blocks (boot, sb, nlog, inode, bitmap)
+int nblocks;  /// Number of data blocks
 
 int fsfd;
 struct superblock sb;
@@ -41,7 +41,7 @@ void rsect(uint sec, void *buf);
 uint ialloc(ushort type);
 void iappend(uint inum, void *p, int n);
 
-// convert to intel byte order
+/// convert to intel byte order
 ushort
 xshort(ushort x)
 {
@@ -90,7 +90,7 @@ main(int argc, char *argv[])
     exit(1);
   }
 
-  // 1 fs block = 1 disk sector
+  /// 1 fs block = 1 disk sector
   nmeta = 2 + nlog + ninodeblocks + nbitmap;
   nblocks = FSSIZE - nmeta;
 
@@ -105,7 +105,7 @@ main(int argc, char *argv[])
   printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n",
          nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
 
-  freeblock = nmeta;     // the first free block that we can allocate
+  freeblock = nmeta;     /// the first free block that we can allocate
 
   for(i = 0; i < FSSIZE; i++)
     wsect(i, zeroes);
@@ -135,10 +135,10 @@ main(int argc, char *argv[])
       exit(1);
     }
 
-    // Skip leading _ in name when writing to file system.
-    // The binaries are named _rm, _cat, etc. to keep the
-    // build operating system from trying to execute them
-    // in place of system binaries like rm and cat.
+    /// Skip leading _ in name when writing to file system.
+    /// The binaries are named _rm, _cat, etc. to keep the
+    /// build operating system from trying to execute them
+    /// in place of system binaries like rm and cat.
     if(argv[i][0] == '_')
       ++argv[i];
 
@@ -155,7 +155,7 @@ main(int argc, char *argv[])
     close(fd);
   }
 
-  // fix size of root inode dir
+  /// fix size of root inode dir
   rinode(rootino, &din);
   off = xint(din.size);
   off = ((off/BSIZE) + 1) * BSIZE;
@@ -264,7 +264,7 @@ iappend(uint inum, void *xp, int n)
 
   rinode(inum, &din);
   off = xint(din.size);
-  // printf("append inum %d at off %d sz %d\n", inum, off, n);
+  /// printf("append inum %d at off %d sz %d\n", inum, off, n);
   while(n > 0){
     fbn = off / BSIZE;
     assert(fbn < MAXFILE);
diff --git a/mmu.h b/mmu.h
old mode 100644
new mode 100755
index a82d8e2..bb58da7
--- a/mmu.h
+++ b/mmu.h
@@ -1,45 +1,45 @@
-// This file contains definitions for the
-// x86 memory management unit (MMU).
+/// This file contains definitions for the
+/// x86 memory management unit (MMU).
 
-// Eflags register
-#define FL_IF           0x00000200      // Interrupt Enable
+/// Eflags register
+#define FL_IF           0x00000200      /// Interrupt Enable
 
-// Control Register flags
-#define CR0_PE          0x00000001      // Protection Enable
-#define CR0_WP          0x00010000      // Write Protect
-#define CR0_PG          0x80000000      // Paging
+/// Control Register flags
+#define CR0_PE          0x00000001      /// Protection Enable
+#define CR0_WP          0x00010000      /// Write Protect
+#define CR0_PG          0x80000000      /// Paging
 
-#define CR4_PSE         0x00000010      // Page size extension
+#define CR4_PSE         0x00000010      /// Page size extension
 
-// various segment selectors.
-#define SEG_KCODE 1  // kernel code
-#define SEG_KDATA 2  // kernel data+stack
-#define SEG_UCODE 3  // user code
-#define SEG_UDATA 4  // user data+stack
-#define SEG_TSS   5  // this process's task state
+/// various segment selectors.
+#define SEG_KCODE 1  /// kernel code
+#define SEG_KDATA 2  /// kernel data+stack
+#define SEG_UCODE 3  /// user code
+#define SEG_UDATA 4  /// user data+stack
+#define SEG_TSS   5  /// this process's task state
 
-// cpu->gdt[NSEGS] holds the above segments.
+/// cpu->gdt[NSEGS] holds the above segments.
 #define NSEGS     6
 
 #ifndef __ASSEMBLER__
-// Segment Descriptor
+/// Segment Descriptor
 struct segdesc {
-  uint lim_15_0 : 16;  // Low bits of segment limit
-  uint base_15_0 : 16; // Low bits of segment base address
-  uint base_23_16 : 8; // Middle bits of segment base address
-  uint type : 4;       // Segment type (see STS_ constants)
-  uint s : 1;          // 0 = system, 1 = application
-  uint dpl : 2;        // Descriptor Privilege Level
-  uint p : 1;          // Present
-  uint lim_19_16 : 4;  // High bits of segment limit
-  uint avl : 1;        // Unused (available for software use)
-  uint rsv1 : 1;       // Reserved
-  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
-  uint g : 1;          // Granularity: limit scaled by 4K when set
-  uint base_31_24 : 8; // High bits of segment base address
+  uint lim_15_0 : 16;  /// Low bits of segment limit
+  uint base_15_0 : 16; /// Low bits of segment base address
+  uint base_23_16 : 8; /// Middle bits of segment base address
+  uint type : 4;       /// Segment type (see STS_ constants)
+  uint s : 1;          /// 0 = system, 1 = application
+  uint dpl : 2;        /// Descriptor Privilege Level
+  uint p : 1;          /// Present
+  uint lim_19_16 : 4;  /// High bits of segment limit
+  uint avl : 1;        /// Unused (available for software use)
+  uint rsv1 : 1;       /// Reserved
+  uint db : 1;         /// 0 = 16-bit segment, 1 = 32-bit segment
+  uint g : 1;          /// Granularity: limit scaled by 4K when set
+  uint base_31_24 : 8; /// High bits of segment base address
 };
 
-// Normal segment
+/// Normal segment
 #define SEG(type, base, lim, dpl) (struct segdesc)    \
 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
@@ -50,64 +50,64 @@ struct segdesc {
   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
 #endif
 
-#define DPL_USER    0x3     // User DPL
+#define DPL_USER    0x3     /// User DPL
 
-// Application segment type bits
-#define STA_X       0x8     // Executable segment
-#define STA_W       0x2     // Writeable (non-executable segments)
-#define STA_R       0x2     // Readable (executable segments)
+/// Application segment type bits
+#define STA_X       0x8     /// Executable segment
+#define STA_W       0x2     /// Writeable (non-executable segments)
+#define STA_R       0x2     /// Readable (executable segments)
 
-// System segment type bits
-#define STS_T32A    0x9     // Available 32-bit TSS
-#define STS_IG32    0xE     // 32-bit Interrupt Gate
-#define STS_TG32    0xF     // 32-bit Trap Gate
+/// System segment type bits
+#define STS_T32A    0x9     /// Available 32-bit TSS
+#define STS_IG32    0xE     /// 32-bit Interrupt Gate
+#define STS_TG32    0xF     /// 32-bit Trap Gate
 
-// A virtual address 'la' has a three-part structure as follows:
-//
-// +--------10------+-------10-------+---------12----------+
-// | Page Directory |   Page Table   | Offset within Page  |
-// |      Index     |      Index     |                     |
-// +----------------+----------------+---------------------+
-//  \--- PDX(va) --/ \--- PTX(va) --/
+/// A virtual address 'la' has a three-part structure as follows:
+///
+/// +--------10------+-------10-------+---------12----------+
+/// | Page Directory |   Page Table   | Offset within Page  |
+/// |      Index     |      Index     |                     |
+/// +----------------+----------------+---------------------+
+///  \--- PDX(va) --/ \--- PTX(va) --/
 
-// page directory index
+/// page directory index
 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
 
-// page table index
+/// page table index
 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
 
-// construct virtual address from indexes and offset
+/// construct virtual address from indexes and offset
 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
 
-// Page directory and page table constants.
-#define NPDENTRIES      1024    // # directory entries per page directory
-#define NPTENTRIES      1024    // # PTEs per page table
-#define PGSIZE          4096    // bytes mapped by a page
+/// Page directory and page table constants.
+#define NPDENTRIES      1024    /// # directory entries per page directory
+#define NPTENTRIES      1024    /// # PTEs per page table
+#define PGSIZE          4096    /// bytes mapped by a page
 
-#define PTXSHIFT        12      // offset of PTX in a linear address
-#define PDXSHIFT        22      // offset of PDX in a linear address
+#define PTXSHIFT        12      /// offset of PTX in a linear address
+#define PDXSHIFT        22      /// offset of PDX in a linear address
 
 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
 
-// Page table/directory entry flags.
-#define PTE_P           0x001   // Present
-#define PTE_W           0x002   // Writeable
-#define PTE_U           0x004   // User
-#define PTE_PS          0x080   // Page Size
+/// Page table/directory entry flags.
+#define PTE_P           0x001   /// Present
+#define PTE_W           0x002   /// Writeable
+#define PTE_U           0x004   /// User
+#define PTE_PS          0x080   /// Page Size
 
-// Address in page table or page directory entry
+/// Address in page table or page directory entry
 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
 
 #ifndef __ASSEMBLER__
 typedef uint pte_t;
 
-// Task state segment format
+/// Task state segment format
 struct taskstate {
-  uint link;         // Old ts selector
-  uint esp0;         // Stack pointers and segment selectors
-  ushort ss0;        //   after an increase in privilege level
+  uint link;         /// Old ts selector
+  uint esp0;         /// Stack pointers and segment selectors
+  ushort ss0;        ///   after an increase in privilege level
   ushort padding1;
   uint *esp1;
   ushort ss1;
@@ -115,10 +115,10 @@ struct taskstate {
   uint *esp2;
   ushort ss2;
   ushort padding3;
-  void *cr3;         // Page directory base
-  uint *eip;         // Saved state from last task switch
+  void *cr3;         /// Page directory base
+  uint *eip;         /// Saved state from last task switch
   uint eflags;
-  uint eax;          // More saved state (registers)
+  uint eax;          /// More saved state (registers)
   uint ecx;
   uint edx;
   uint ebx;
@@ -126,7 +126,7 @@ struct taskstate {
   uint *ebp;
   uint esi;
   uint edi;
-  ushort es;         // Even more saved state (segment selectors)
+  ushort es;         /// Even more saved state (segment selectors)
   ushort padding4;
   ushort cs;
   ushort padding5;
@@ -140,31 +140,31 @@ struct taskstate {
   ushort padding9;
   ushort ldt;
   ushort padding10;
-  ushort t;          // Trap on task switch
-  ushort iomb;       // I/O map base address
+  ushort t;          /// Trap on task switch
+  ushort iomb;       /// I/O map base address
 };
 
-// Gate descriptors for interrupts and traps
+/// Gate descriptors for interrupts and traps
 struct gatedesc {
-  uint off_15_0 : 16;   // low 16 bits of offset in segment
-  uint cs : 16;         // code segment selector
-  uint args : 5;        // # args, 0 for interrupt/trap gates
-  uint rsv1 : 3;        // reserved(should be zero I guess)
-  uint type : 4;        // type(STS_{IG32,TG32})
-  uint s : 1;           // must be 0 (system)
-  uint dpl : 2;         // descriptor(meaning new) privilege level
-  uint p : 1;           // Present
-  uint off_31_16 : 16;  // high bits of offset in segment
+  uint off_15_0 : 16;   /// low 16 bits of offset in segment
+  uint cs : 16;         /// code segment selector
+  uint args : 5;        /// # args, 0 for interrupt/trap gates
+  uint rsv1 : 3;        /// reserved(should be zero I guess)
+  uint type : 4;        /// type(STS_{IG32,TG32})
+  uint s : 1;           /// must be 0 (system)
+  uint dpl : 2;         /// descriptor(meaning new) privilege level
+  uint p : 1;           /// Present
+  uint off_31_16 : 16;  /// high bits of offset in segment
 };
 
-// Set up a normal interrupt/trap gate descriptor.
-// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
-//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
-// - sel: Code segment selector for interrupt/trap handler
-// - off: Offset in code segment for interrupt/trap handler
-// - dpl: Descriptor Privilege Level -
-//        the privilege level required for software to invoke
-//        this interrupt/trap gate explicitly using an int instruction.
+/// Set up a normal interrupt/trap gate descriptor.
+/// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
+///   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
+/// - sel: Code segment selector for interrupt/trap handler
+/// - off: Offset in code segment for interrupt/trap handler
+/// - dpl: Descriptor Privilege Level -
+///        the privilege level required for software to invoke
+///        this interrupt/trap gate explicitly using an int instruction.
 #define SETGATE(gate, istrap, sel, off, d)                \
 {                                                         \
   (gate).off_15_0 = (uint)(off) & 0xffff;                \
diff --git a/mp.c b/mp.c
old mode 100644
new mode 100755
index 79bb0ad..e5deb67
--- a/mp.c
+++ b/mp.c
@@ -1,6 +1,6 @@
-// Multiprocessor support
-// Search memory for MP description structures.
-// http://developer.intel.com/design/pentium/datashts/24201606.pdf
+/// Multiprocessor support
+/// Search memory for MP description structures.
+/// http:///developer.intel.com/design/pentium/datashts/24201606.pdf
 
 #include "types.h"
 #include "defs.h"
@@ -26,7 +26,7 @@ sum(uchar *addr, int len)
   return sum;
 }
 
-// Look for an MP structure in the len bytes at addr.
+/// Look for an MP structure in the len bytes at addr.
 static struct mp*
 mpsearch1(uint a, int len)
 {
@@ -40,11 +40,11 @@ mpsearch1(uint a, int len)
   return 0;
 }
 
-// Search for the MP Floating Pointer Structure, which according to the
-// spec is in one of the following three locations:
-// 1) in the first KB of the EBDA;
-// 2) in the last KB of system base memory;
-// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
+/// Search for the MP Floating Pointer Structure, which according to the
+/// spec is in one of the following three locations:
+/// 1) in the first KB of the EBDA;
+/// 2) in the last KB of system base memory;
+/// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
 static struct mp*
 mpsearch(void)
 {
@@ -64,11 +64,11 @@ mpsearch(void)
   return mpsearch1(0xF0000, 0x10000);
 }
 
-// Search for an MP configuration table.  For now,
-// don't accept the default configurations (physaddr == 0).
-// Check for correct signature, calculate the checksum and,
-// if correct, check the version.
-// To do: check extended table checksum.
+/// Search for an MP configuration table.  For now,
+/// don't accept the default configurations (physaddr == 0).
+/// Check for correct signature, calculate the checksum and,
+/// if correct, check the version.
+/// To do: check extended table checksum.
 static struct mpconf*
 mpconfig(struct mp **pmp)
 {
@@ -107,7 +107,7 @@ mpinit(void)
     case MPPROC:
       proc = (struct mpproc*)p;
       if(ncpu < NCPU) {
-        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+        cpus[ncpu].apicid = proc->apicid;  /// apicid may differ from ncpu
         ncpu++;
       }
       p += sizeof(struct mpproc);
@@ -131,9 +131,9 @@ mpinit(void)
     panic("Didn't find a suitable machine");
 
   if(mp->imcrp){
-    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
-    // But it would on real hardware.
-    outb(0x22, 0x70);   // Select IMCR
-    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
+    /// Bochs doesn't support IMCR, so this doesn't run on Bochs.
+    /// But it would on real hardware.
+    outb(0x22, 0x70);   /// Select IMCR
+    outb(0x23, inb(0x23) | 1);  /// Mask external interrupts.
   }
 }
diff --git a/mp.h b/mp.h
old mode 100644
new mode 100755
index 4d17283..3352ff2
--- a/mp.h
+++ b/mp.h
@@ -1,56 +1,56 @@
-// See MultiProcessor Specification Version 1.[14]
+/// See MultiProcessor Specification Version 1.[14]
 
-struct mp {             // floating pointer
-  uchar signature[4];           // "_MP_"
-  void *physaddr;               // phys addr of MP config table
-  uchar length;                 // 1
-  uchar specrev;                // [14]
-  uchar checksum;               // all bytes must add up to 0
-  uchar type;                   // MP system config type
+struct mp {             /// floating pointer
+  uchar signature[4];           /// "_MP_"
+  void *physaddr;               /// phys addr of MP config table
+  uchar length;                 /// 1
+  uchar specrev;                /// [14]
+  uchar checksum;               /// all bytes must add up to 0
+  uchar type;                   /// MP system config type
   uchar imcrp;
   uchar reserved[3];
 };
 
-struct mpconf {         // configuration table header
-  uchar signature[4];           // "PCMP"
-  ushort length;                // total table length
-  uchar version;                // [14]
-  uchar checksum;               // all bytes must add up to 0
-  uchar product[20];            // product id
-  uint *oemtable;               // OEM table pointer
-  ushort oemlength;             // OEM table length
-  ushort entry;                 // entry count
-  uint *lapicaddr;              // address of local APIC
-  ushort xlength;               // extended table length
-  uchar xchecksum;              // extended table checksum
+struct mpconf {         /// configuration table header
+  uchar signature[4];           /// "PCMP"
+  ushort length;                /// total table length
+  uchar version;                /// [14]
+  uchar checksum;               /// all bytes must add up to 0
+  uchar product[20];            /// product id
+  uint *oemtable;               /// OEM table pointer
+  ushort oemlength;             /// OEM table length
+  ushort entry;                 /// entry count
+  uint *lapicaddr;              /// address of local APIC
+  ushort xlength;               /// extended table length
+  uchar xchecksum;              /// extended table checksum
   uchar reserved;
 };
 
-struct mpproc {         // processor table entry
-  uchar type;                   // entry type (0)
-  uchar apicid;                 // local APIC id
-  uchar version;                // local APIC verison
-  uchar flags;                  // CPU flags
-    #define MPBOOT 0x02           // This proc is the bootstrap processor.
-  uchar signature[4];           // CPU signature
-  uint feature;                 // feature flags from CPUID instruction
+struct mpproc {         /// processor table entry
+  uchar type;                   /// entry type (0)
+  uchar apicid;                 /// local APIC id
+  uchar version;                /// local APIC verison
+  uchar flags;                  /// CPU flags
+    #define MPBOOT 0x02           /// This proc is the bootstrap processor.
+  uchar signature[4];           /// CPU signature
+  uint feature;                 /// feature flags from CPUID instruction
   uchar reserved[8];
 };
 
-struct mpioapic {       // I/O APIC table entry
-  uchar type;                   // entry type (2)
-  uchar apicno;                 // I/O APIC id
-  uchar version;                // I/O APIC version
-  uchar flags;                  // I/O APIC flags
-  uint *addr;                  // I/O APIC address
+struct mpioapic {       /// I/O APIC table entry
+  uchar type;                   /// entry type (2)
+  uchar apicno;                 /// I/O APIC id
+  uchar version;                /// I/O APIC version
+  uchar flags;                  /// I/O APIC flags
+  uint *addr;                  /// I/O APIC address
 };
 
-// Table entry types
-#define MPPROC    0x00  // One per processor
-#define MPBUS     0x01  // One per bus
-#define MPIOAPIC  0x02  // One per I/O APIC
-#define MPIOINTR  0x03  // One per bus interrupt source
-#define MPLINTR   0x04  // One per system interrupt source
+/// Table entry types
+#define MPPROC    0x00  /// One per processor
+#define MPBUS     0x01  /// One per bus
+#define MPIOAPIC  0x02  /// One per I/O APIC
+#define MPIOINTR  0x03  /// One per bus interrupt source
+#define MPLINTR   0x04  /// One per system interrupt source
 
-//PAGEBREAK!
-// Blank page.
+///PAGEBREAK!
+/// Blank page.
diff --git a/param.h b/param.h
old mode 100644
new mode 100755
index a7e90ef..f61377a
--- a/param.h
+++ b/param.h
@@ -1,14 +1,17 @@
-#define NPROC        64  // maximum number of processes
-#define KSTACKSIZE 4096  // size of per-process kernel stack
-#define NCPU          8  // maximum number of CPUs
-#define NOFILE       16  // open files per process
-#define NFILE       100  // open files per system
-#define NINODE       50  // maximum number of active i-nodes
-#define NDEV         10  // maximum major device number
-#define ROOTDEV       1  // device number of file system root disk
-#define MAXARG       32  // max exec arguments
-#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
-#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
-#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-#define FSSIZE       1000  // size of file system in blocks
+#define SOCKET_BUFFER_SIZE 128 ///maximum buffer length
+#define NPORT       128  /// maximum number of ports
+#define NSOCK        32  /// maximum number of sockets
+#define NPROC        64  /// maximum number of processes
+#define KSTACKSIZE 4096  /// size of per-process kernel stack
+#define NCPU          8  /// maximum number of CPUs
+#define NOFILE       16  /// open files per process
+#define NFILE       100  /// open files per system
+#define NINODE       50  /// maximum number of active i-nodes
+#define NDEV         10  /// maximum major device number
+#define ROOTDEV       1  /// device number of file system root disk
+#define MAXARG       32  /// max exec arguments
+#define MAXOPBLOCKS  10  /// max # of blocks any FS op writes
+#define LOGSIZE      (MAXOPBLOCKS*3)  /// max data blocks in on-disk log
+#define NBUF         (MAXOPBLOCKS*3)  /// size of disk block cache
+#define FSSIZE       1000  /// size of file system in blocks
 
diff --git a/picirq.c b/picirq.c
old mode 100644
new mode 100755
index e26957f..b2c4716
--- a/picirq.c
+++ b/picirq.c
@@ -2,18 +2,18 @@
 #include "x86.h"
 #include "traps.h"
 
-// I/O Addresses of the two programmable interrupt controllers
-#define IO_PIC1         0x20    // Master (IRQs 0-7)
-#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
+/// I/O Addresses of the two programmable interrupt controllers
+#define IO_PIC1         0x20    /// Master (IRQs 0-7)
+#define IO_PIC2         0xA0    /// Slave (IRQs 8-15)
 
-// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
+/// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
 void
 picinit(void)
 {
-  // mask all interrupts
+  /// mask all interrupts
   outb(IO_PIC1+1, 0xFF);
   outb(IO_PIC2+1, 0xFF);
 }
 
-//PAGEBREAK!
-// Blank page.
+///PAGEBREAK!
+/// Blank page.
diff --git a/pipe.c b/pipe.c
old mode 100644
new mode 100755
index e9abe7f..4b3a186
--- a/pipe.c
+++ b/pipe.c
@@ -13,10 +13,10 @@
 struct pipe {
   struct spinlock lock;
   char data[PIPESIZE];
-  uint nread;     // number of bytes read
-  uint nwrite;    // number of bytes written
-  int readopen;   // read fd is still open
-  int writeopen;  // write fd is still open
+  uint nread;     /// number of bytes read
+  uint nwrite;    /// number of bytes written
+  int readopen;   /// read fd is still open
+  int writeopen;  /// write fd is still open
 };
 
 int
@@ -45,7 +45,7 @@ pipealloc(struct file **f0, struct file **f1)
   (*f1)->pipe = p;
   return 0;
 
-//PAGEBREAK: 20
+///PAGEBREAK: 20
  bad:
   if(p)
     kfree((char*)p);
@@ -74,7 +74,7 @@ pipeclose(struct pipe *p, int writable)
     release(&p->lock);
 }
 
-//PAGEBREAK: 40
+///PAGEBREAK: 40
 int
 pipewrite(struct pipe *p, char *addr, int n)
 {
@@ -82,17 +82,17 @@ pipewrite(struct pipe *p, char *addr, int n)
 
   acquire(&p->lock);
   for(i = 0; i < n; i++){
-    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+    while(p->nwrite == p->nread + PIPESIZE){  ///DOC: pipewrite-full
       if(p->readopen == 0 || myproc()->killed){
         release(&p->lock);
         return -1;
       }
       wakeup(&p->nread);
-      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+      sleep(&p->nwrite, &p->lock);  ///DOC: pipewrite-sleep
     }
     p->data[p->nwrite++ % PIPESIZE] = addr[i];
   }
-  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+  wakeup(&p->nread);  ///DOC: pipewrite-wakeup1
   release(&p->lock);
   return n;
 }
@@ -103,19 +103,19 @@ piperead(struct pipe *p, char *addr, int n)
   int i;
 
   acquire(&p->lock);
-  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+  while(p->nread == p->nwrite && p->writeopen){  ///DOC: pipe-empty
     if(myproc()->killed){
       release(&p->lock);
       return -1;
     }
-    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+    sleep(&p->nread, &p->lock); ///DOC: piperead-sleep
   }
-  for(i = 0; i < n; i++){  //DOC: piperead-copy
+  for(i = 0; i < n; i++){  ///DOC: piperead-copy
     if(p->nread == p->nwrite)
       break;
     addr[i] = p->data[p->nread++ % PIPESIZE];
   }
-  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+  wakeup(&p->nwrite);  ///DOC: piperead-wakeup
   release(&p->lock);
   return i;
 }
diff --git a/pr.pl b/pr.pl
index 46905bd..236f6a6 100755
--- a/pr.pl
+++ b/pr.pl
@@ -20,7 +20,7 @@ for($i=0; $i<@lines; $i+=50){
 	print "$now  $h  Page $page\n";
 	print "\n\n";
 	for($j=$i; $j<@lines && $j<$i +50; $j++){
-		$lines[$j] =~ s!//DOC.*!!;
+		$lines[$j] =~ s!///DOC.*!!;
 		print $lines[$j];
 	}
 	for(; $j<$i+50; $j++){
diff --git a/printf.c b/printf.c
old mode 100644
new mode 100755
index b3298aa..2125235
--- a/printf.c
+++ b/printf.c
@@ -35,7 +35,7 @@ printint(int fd, int xx, int base, int sgn)
     putc(fd, buf[i]);
 }
 
-// Print to the given fd. Only understands %d, %x, %p, %s.
+/// Print to the given fd. Only understands %d, %x, %p, %s.
 void
 printf(int fd, const char *fmt, ...)
 {
@@ -75,7 +75,7 @@ printf(int fd, const char *fmt, ...)
       } else if(c == '%'){
         putc(fd, c);
       } else {
-        // Unknown % sequence.  Print it to draw attention.
+        /// Unknown % sequence.  Print it to draw attention.
         putc(fd, '%');
         putc(fd, c);
       }
diff --git a/proc.c b/proc.c
old mode 100644
new mode 100755
index 806b1b1..d5f41cb
--- a/proc.c
+++ b/proc.c
@@ -26,25 +26,25 @@ pinit(void)
   initlock(&ptable.lock, "ptable");
 }
 
-// Must be called with interrupts disabled
+/// Must be called with interrupts disabled
 int
 cpuid() {
   return mycpu()-cpus;
 }
 
-// Must be called with interrupts disabled to avoid the caller being
-// rescheduled between reading lapicid and running through the loop.
+/// Must be called with interrupts disabled to avoid the caller being
+/// rescheduled between reading lapicid and running through the loop.
 struct cpu*
 mycpu(void)
 {
   int apicid, i;
-  
+
   if(readeflags()&FL_IF)
     panic("mycpu called with interrupts enabled\n");
-  
+
   apicid = lapicid();
-  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
-  // a reverse map, or reserve a register to store &cpus[i].
+  /// APIC IDs are not guaranteed to be contiguous. Maybe we should have
+  /// a reverse map, or reserve a register to store &cpus[i].
   for (i = 0; i < ncpu; ++i) {
     if (cpus[i].apicid == apicid)
       return &cpus[i];
@@ -52,8 +52,8 @@ mycpu(void)
   panic("unknown apicid\n");
 }
 
-// Disable interrupts so that we are not rescheduled
-// while reading proc from the cpu structure
+/// Disable interrupts so that we are not rescheduled
+/// while reading proc from the cpu structure
 struct proc*
 myproc(void) {
   struct cpu *c;
@@ -65,11 +65,11 @@ myproc(void) {
   return p;
 }
 
-//PAGEBREAK: 32
-// Look in the process table for an UNUSED proc.
-// If found, change state to EMBRYO and initialize
-// state required to run in the kernel.
-// Otherwise return 0.
+///PAGEBREAK: 32
+/// Look in the process table for an UNUSED proc.
+/// If found, change state to EMBRYO and initialize
+/// state required to run in the kernel.
+/// Otherwise return 0.
 static struct proc*
 allocproc(void)
 {
@@ -91,19 +91,19 @@ found:
 
   release(&ptable.lock);
 
-  // Allocate kernel stack.
+  /// Allocate kernel stack.
   if((p->kstack = kalloc()) == 0){
     p->state = UNUSED;
     return 0;
   }
   sp = p->kstack + KSTACKSIZE;
 
-  // Leave room for trap frame.
+  /// Leave room for trap frame.
   sp -= sizeof *p->tf;
   p->tf = (struct trapframe*)sp;
 
-  // Set up new context to start executing at forkret,
-  // which returns to trapret.
+  /// Set up new context to start executing at forkret,
+  /// which returns to trapret.
   sp -= 4;
   *(uint*)sp = (uint)trapret;
 
@@ -115,8 +115,8 @@ found:
   return p;
 }
 
-//PAGEBREAK: 32
-// Set up first user process.
+///PAGEBREAK: 32
+/// Set up first user process.
 void
 userinit(void)
 {
@@ -124,7 +124,7 @@ userinit(void)
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
+
   initproc = p;
   if((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
@@ -137,15 +137,15 @@ userinit(void)
   p->tf->ss = p->tf->ds;
   p->tf->eflags = FL_IF;
   p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
+  p->tf->eip = 0;  /// beginning of initcode.S
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
-  // this assignment to p->state lets other cores
-  // run this process. the acquire forces the above
-  // writes to be visible, and the lock is also needed
-  // because the assignment might not be atomic.
+  /// this assignment to p->state lets other cores
+  /// run this process. the acquire forces the above
+  /// writes to be visible, and the lock is also needed
+  /// because the assignment might not be atomic.
   acquire(&ptable.lock);
 
   p->state = RUNNABLE;
@@ -153,8 +153,8 @@ userinit(void)
   release(&ptable.lock);
 }
 
-// Grow current process's memory by n bytes.
-// Return 0 on success, -1 on failure.
+/// Grow current process's memory by n bytes.
+/// Return 0 on success, -1 on failure.
 int
 growproc(int n)
 {
@@ -174,9 +174,9 @@ growproc(int n)
   return 0;
 }
 
-// Create a new process copying p as the parent.
-// Sets up stack to return as if from system call.
-// Caller must set state of returned proc to RUNNABLE.
+/// Create a new process copying p as the parent.
+/// Sets up stack to return as if from system call.
+/// Caller must set state of returned proc to RUNNABLE.
 int
 fork(void)
 {
@@ -184,12 +184,12 @@ fork(void)
   struct proc *np;
   struct proc *curproc = myproc();
 
-  // Allocate process.
+  /// Allocate process.
   if((np = allocproc()) == 0){
     return -1;
   }
 
-  // Copy process state from proc.
+  /// Copy process state from proc.
   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
     kfree(np->kstack);
     np->kstack = 0;
@@ -200,7 +200,7 @@ fork(void)
   np->parent = curproc;
   *np->tf = *curproc->tf;
 
-  // Clear %eax so that fork returns 0 in the child.
+  /// Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
   for(i = 0; i < NOFILE; i++)
@@ -221,9 +221,9 @@ fork(void)
   return pid;
 }
 
-// Exit the current process.  Does not return.
-// An exited process remains in the zombie state
-// until its parent calls wait() to find out it exited.
+/// Exit the current process.  Does not return.
+/// An exited process remains in the zombie state
+/// until its parent calls wait() to find out it exited.
 void
 exit(void)
 {
@@ -234,7 +234,7 @@ exit(void)
   if(curproc == initproc)
     panic("init exiting");
 
-  // Close all open files.
+  /// Close all open files.
   for(fd = 0; fd < NOFILE; fd++){
     if(curproc->ofile[fd]){
       fileclose(curproc->ofile[fd]);
@@ -249,10 +249,10 @@ exit(void)
 
   acquire(&ptable.lock);
 
-  // Parent might be sleeping in wait().
+  /// Parent might be sleeping in wait().
   wakeup1(curproc->parent);
 
-  // Pass abandoned children to init.
+  /// Pass abandoned children to init.
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->parent == curproc){
       p->parent = initproc;
@@ -261,31 +261,31 @@ exit(void)
     }
   }
 
-  // Jump into the scheduler, never to return.
+  /// Jump into the scheduler, never to return.
   curproc->state = ZOMBIE;
   sched();
   panic("zombie exit");
 }
 
-// Wait for a child process to exit and return its pid.
-// Return -1 if this process has no children.
+/// Wait for a child process to exit and return its pid.
+/// Return -1 if this process has no children.
 int
 wait(void)
 {
   struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
-  
+
   acquire(&ptable.lock);
   for(;;){
-    // Scan through table looking for exited children.
+    /// Scan through table looking for exited children.
     havekids = 0;
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->parent != curproc)
         continue;
       havekids = 1;
       if(p->state == ZOMBIE){
-        // Found one.
+        /// Found one.
         pid = p->pid;
         kfree(p->kstack);
         p->kstack = 0;
@@ -300,45 +300,45 @@ wait(void)
       }
     }
 
-    // No point waiting if we don't have any children.
+    /// No point waiting if we don't have any children.
     if(!havekids || curproc->killed){
       release(&ptable.lock);
       return -1;
     }
 
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    /// Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(curproc, &ptable.lock);  ///DOC: wait-sleep
   }
 }
 
-//PAGEBREAK: 42
-// Per-CPU process scheduler.
-// Each CPU calls scheduler() after setting itself up.
-// Scheduler never returns.  It loops, doing:
-//  - choose a process to run
-//  - swtch to start running that process
-//  - eventually that process transfers control
-//      via swtch back to the scheduler.
+///PAGEBREAK: 42
+/// Per-CPU process scheduler.
+/// Each CPU calls scheduler() after setting itself up.
+/// Scheduler never returns.  It loops, doing:
+///  - choose a process to run
+///  - swtch to start running that process
+///  - eventually that process transfers control
+///      via swtch back to the scheduler.
 void
 scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
+
   for(;;){
-    // Enable interrupts on this processor.
+    /// Enable interrupts on this processor.
     sti();
 
-    // Loop over process table looking for process to run.
+    /// Loop over process table looking for process to run.
     acquire(&ptable.lock);
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->state != RUNNABLE)
         continue;
 
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
+      /// Switch to chosen process.  It is the process's job
+      /// to release ptable.lock and then reacquire it
+      /// before jumping back to us.
       c->proc = p;
       switchuvm(p);
       p->state = RUNNING;
@@ -346,8 +346,8 @@ scheduler(void)
       swtch(&(c->scheduler), p->context);
       switchkvm();
 
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
+      /// Process is done running for now.
+      /// It should have changed its p->state before coming back.
       c->proc = 0;
     }
     release(&ptable.lock);
@@ -355,13 +355,13 @@ scheduler(void)
   }
 }
 
-// Enter scheduler.  Must hold only ptable.lock
-// and have changed proc->state. Saves and restores
-// intena because intena is a property of this
-// kernel thread, not this CPU. It should
-// be proc->intena and proc->ncli, but that would
-// break in the few places where a lock is held but
-// there's no process.
+/// Enter scheduler.  Must hold only ptable.lock
+/// and have changed proc->state. Saves and restores
+/// intena because intena is a property of this
+/// kernel thread, not this CPU. It should
+/// be proc->intena and proc->ncli, but that would
+/// break in the few places where a lock is held but
+/// there's no process.
 void
 sched(void)
 {
@@ -381,79 +381,79 @@ sched(void)
   mycpu()->intena = intena;
 }
 
-// Give up the CPU for one scheduling round.
+/// Give up the CPU for one scheduling round.
 void
 yield(void)
 {
-  acquire(&ptable.lock);  //DOC: yieldlock
+  acquire(&ptable.lock);  ///DOC: yieldlock
   myproc()->state = RUNNABLE;
   sched();
   release(&ptable.lock);
 }
 
-// A fork child's very first scheduling by scheduler()
-// will swtch here.  "Return" to user space.
+/// A fork child's very first scheduling by scheduler()
+/// will swtch here.  "Return" to user space.
 void
 forkret(void)
 {
   static int first = 1;
-  // Still holding ptable.lock from scheduler.
+  /// Still holding ptable.lock from scheduler.
   release(&ptable.lock);
 
   if (first) {
-    // Some initialization functions must be run in the context
-    // of a regular process (e.g., they call sleep), and thus cannot
-    // be run from main().
+    /// Some initialization functions must be run in the context
+    /// of a regular process (e.g., they call sleep), and thus cannot
+    /// be run from main().
     first = 0;
     iinit(ROOTDEV);
     initlog(ROOTDEV);
   }
 
-  // Return to "caller", actually trapret (see allocproc).
+  /// Return to "caller", actually trapret (see allocproc).
 }
 
-// Atomically release lock and sleep on chan.
-// Reacquires lock when awakened.
+/// Atomically release lock and sleep on chan.
+/// Reacquires lock when awakened.
 void
 sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
+
   if(p == 0)
     panic("sleep");
 
   if(lk == 0)
     panic("sleep without lk");
 
-  // Must acquire ptable.lock in order to
-  // change p->state and then call sched.
-  // Once we hold ptable.lock, we can be
-  // guaranteed that we won't miss any wakeup
-  // (wakeup runs with ptable.lock locked),
-  // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
+  /// Must acquire ptable.lock in order to
+  /// change p->state and then call sched.
+  /// Once we hold ptable.lock, we can be
+  /// guaranteed that we won't miss any wakeup
+  /// (wakeup runs with ptable.lock locked),
+  /// so it's okay to release lk.
+  if(lk != &ptable.lock){  ///DOC: sleeplock0
+    acquire(&ptable.lock);  ///DOC: sleeplock1
     release(lk);
   }
-  // Go to sleep.
+  /// Go to sleep.
   p->chan = chan;
   p->state = SLEEPING;
 
   sched();
 
-  // Tidy up.
+  /// Tidy up.
   p->chan = 0;
 
-  // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
+  /// Reacquire original lock.
+  if(lk != &ptable.lock){  ///DOC: sleeplock2
     release(&ptable.lock);
     acquire(lk);
   }
 }
 
-//PAGEBREAK!
-// Wake up all processes sleeping on chan.
-// The ptable lock must be held.
+///PAGEBREAK!
+/// Wake up all processes sleeping on chan.
+/// The ptable lock must be held.
 static void
 wakeup1(void *chan)
 {
@@ -464,7 +464,7 @@ wakeup1(void *chan)
       p->state = RUNNABLE;
 }
 
-// Wake up all processes sleeping on chan.
+/// Wake up all processes sleeping on chan.
 void
 wakeup(void *chan)
 {
@@ -473,9 +473,9 @@ wakeup(void *chan)
   release(&ptable.lock);
 }
 
-// Kill the process with the given pid.
-// Process won't exit until it returns
-// to user space (see trap in trap.c).
+/// Kill the process with the given pid.
+/// Process won't exit until it returns
+/// to user space (see trap in trap.c).
 int
 kill(int pid)
 {
@@ -485,7 +485,7 @@ kill(int pid)
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->pid == pid){
       p->killed = 1;
-      // Wake process from sleep if necessary.
+      /// Wake process from sleep if necessary.
       if(p->state == SLEEPING)
         p->state = RUNNABLE;
       release(&ptable.lock);
@@ -496,10 +496,10 @@ kill(int pid)
   return -1;
 }
 
-//PAGEBREAK: 36
-// Print a process listing to console.  For debugging.
-// Runs when user types ^P on console.
-// No lock to avoid wedging a stuck machine further.
+///PAGEBREAK: 36
+/// Print a process listing to console.  For debugging.
+/// Runs when user types ^P on console.
+/// No lock to avoid wedging a stuck machine further.
 void
 procdump(void)
 {
diff --git a/proc.h b/proc.h
old mode 100644
new mode 100755
index 1647114..29ad904
--- a/proc.h
+++ b/proc.h
@@ -1,29 +1,29 @@
-// Per-CPU state
+/// Per-CPU state
 struct cpu {
-  uchar apicid;                // Local APIC ID
-  struct context *scheduler;   // swtch() here to enter scheduler
-  struct taskstate ts;         // Used by x86 to find stack for interrupt
-  struct segdesc gdt[NSEGS];   // x86 global descriptor table
-  volatile uint started;       // Has the CPU started?
-  int ncli;                    // Depth of pushcli nesting.
-  int intena;                  // Were interrupts enabled before pushcli?
-  struct proc *proc;           // The process running on this cpu or null
+  uchar apicid;                /// Local APIC ID
+  struct context *scheduler;   /// swtch() here to enter scheduler
+  struct taskstate ts;         /// Used by x86 to find stack for interrupt
+  struct segdesc gdt[NSEGS];   /// x86 global descriptor table
+  volatile uint started;       /// Has the CPU started?
+  int ncli;                    /// Depth of pushcli nesting.
+  int intena;                  /// Were interrupts enabled before pushcli?
+  struct proc *proc;           /// The process running on this cpu or null
 };
 
 extern struct cpu cpus[NCPU];
 extern int ncpu;
 
-//PAGEBREAK: 17
-// Saved registers for kernel context switches.
-// Don't need to save all the segment registers (%cs, etc),
-// because they are constant across kernel contexts.
-// Don't need to save %eax, %ecx, %edx, because the
-// x86 convention is that the caller has saved them.
-// Contexts are stored at the bottom of the stack they
-// describe; the stack pointer is the address of the context.
-// The layout of the context matches the layout of the stack in swtch.S
-// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
-// but it is on the stack and allocproc() manipulates it.
+///PAGEBREAK: 17
+/// Saved registers for kernel context switches.
+/// Don't need to save all the segment registers (%cs, etc),
+/// because they are constant across kernel contexts.
+/// Don't need to save %eax, %ecx, %edx, because the
+/// x86 convention is that the caller has saved them.
+/// Contexts are stored at the bottom of the stack they
+/// describe; the stack pointer is the address of the context.
+/// The layout of the context matches the layout of the stack in swtch.S
+/// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
+/// but it is on the stack and allocproc() manipulates it.
 struct context {
   uint edi;
   uint esi;
@@ -34,25 +34,25 @@ struct context {
 
 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
-// Per-process state
+/// Per-process state
 struct proc {
-  uint sz;                     // Size of process memory (bytes)
-  pde_t* pgdir;                // Page table
-  char *kstack;                // Bottom of kernel stack for this process
-  enum procstate state;        // Process state
-  int pid;                     // Process ID
-  struct proc *parent;         // Parent process
-  struct trapframe *tf;        // Trap frame for current syscall
-  struct context *context;     // swtch() here to run process
-  void *chan;                  // If non-zero, sleeping on chan
-  int killed;                  // If non-zero, have been killed
-  struct file *ofile[NOFILE];  // Open files
-  struct inode *cwd;           // Current directory
-  char name[16];               // Process name (debugging)
+  uint sz;                     /// Size of process memory (bytes)
+  pde_t* pgdir;                /// Page table
+  char *kstack;                /// Bottom of kernel stack for this process
+  enum procstate state;        /// Process state
+  int pid;                     /// Process ID
+  struct proc *parent;         /// Parent process
+  struct trapframe *tf;        /// Trap frame for current syscall
+  struct context *context;     /// swtch() here to run process
+  void *chan;                  /// If non-zero, sleeping on chan
+  int killed;                  /// If non-zero, have been killed
+  struct file *ofile[NOFILE];  /// Open files
+  struct inode *cwd;           /// Current directory
+  char name[16];               /// Process name (debugging)
 };
 
-// Process memory is laid out contiguously, low addresses first:
-//   text
-//   original data and bss
-//   fixed-size stack
-//   expandable heap
+/// Process memory is laid out contiguously, low addresses first:
+///   text
+///   original data and bss
+///   fixed-size stack
+///   expandable heap
diff --git a/rm.c b/rm.c
old mode 100644
new mode 100755
diff --git a/runoff b/runoff
index be362d0..5b60327 100755
--- a/runoff
+++ b/runoff
@@ -20,7 +20,7 @@ n=99
 for i in $files
 do
 	./runoff1 -n $n $i >fmt/$i
-	nn=`tail -1 fmt/$i | sed 's/ .*//; s/^0*//'`
+	nn=`tail -1 fmt/$i | sed 's/ .*///; s/^0*///'`
 	if [ "x$nn" != x ]; then
 		n=$nn
 	fi
@@ -53,19 +53,19 @@ perl -e '
 		s!\s+! !g;
 		s! +$!!;
 		next if /^$/;
-		
+
 		if(/TOC: (\d+) (.*)/){
 			$toc{$2} = $1;
 			next;
 		}
-		
+
 		if(/sheet1: (left|right)$/){
 			print STDERR "assuming that sheet 1 is a $1 page.  double-check!\n";
 			$left = $1 eq "left" ? "13579" : "02468";
 			$right = $1 eq "left" ? "02468" : "13579";
 			next;
 		}
-		
+
 		if(/even: (.*)/){
 			$file = $1;
 			if(!defined($toc{$file})){
@@ -77,7 +77,7 @@ perl -e '
 			}
 			next;
 		}
-		
+
 		if(/odd: (.*)/){
 			$file = $1;
 			if(!defined($toc{$file})){
@@ -89,7 +89,7 @@ perl -e '
 			}
 			next;
 		}
-		
+
 		if(/(left|right): (.*)/){
 			$what = $1;
 			$file = $2;
@@ -107,7 +107,7 @@ perl -e '
 			}
 			next;
 		}
-		
+
 		print STDERR "Unknown spec: $_\n";
 	}
 ' fmt/tocdata runoff.spec
@@ -118,7 +118,7 @@ perl -e '
 	while(<>) {
 		chomp;
 
-		s!//.*!!;
+		s!///.*!!;
 		s!/\*([^*]|[*][^/])*\*/!!g;
 		s!\s! !g;
 		s! +$!!;
@@ -142,14 +142,14 @@ perl -e '
 		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+)/) {
 			print "$1 $2\n";
 		}
-		
+
 		if(/^^([0-9]+) \.globl ([a-zA-Z0-9_]+)/){
 			$isglobl{$2} = 1;
 		}
 		if(/^^([0-9]+) ([a-zA-Z0-9_]+):$/ && $isglobl{$2}){
 			print "$1 $2\n";
 		}
-		
+
 		if (/\(/) {
 			next;
 		}
@@ -157,8 +157,8 @@ perl -e '
 		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {
 			print "$1 $7\n";
 		}
-		
-		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ 
+
+		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){
 			print "$1 $3\n";
 		}
 		# TODO: enum members
@@ -169,10 +169,10 @@ perl -e '
 do
 	case "$i" in
 	*.S)
-		cat $i | sed 's;#.*;;; s;//.*;;;'
+		cat $i | sed 's;#.*;;; s;///.*;;;'
 		;;
 	*)
-		cat $i | sed 's;//.*;;; s;"([^"\\]|\\.)*";;;'
+		cat $i | sed 's;///.*;;; s;"([^"\\]|\\.)*";;;'
 	esac
 done
 ) >alltext
diff --git a/runoff.list b/runoff.list
old mode 100644
new mode 100755
diff --git a/runoff.spec b/runoff.spec
old mode 100644
new mode 100755
diff --git a/runoff1 b/runoff1
index 532f844..2c58937 100755
--- a/runoff1
+++ b/runoff1
@@ -19,7 +19,7 @@ $linenum = 0;
 foreach (@lines) {
 	$linenum++;
 	chomp;
-	s/\s+$//;
+	s/\s+$///;
 	if(length() >= 75){
 		print STDERR "$file:$linenum: line too long\n";
 	}
diff --git a/sh.c b/sh.c
old mode 100644
new mode 100755
index 054bab9..ff5020d
--- a/sh.c
+++ b/sh.c
@@ -1,10 +1,10 @@
-// Shell.
+/// Shell.
 
 #include "types.h"
 #include "user.h"
 #include "fcntl.h"
 
-// Parsed command representation
+/// Parsed command representation
 #define EXEC  1
 #define REDIR 2
 #define PIPE  3
@@ -49,11 +49,11 @@ struct backcmd {
   struct cmd *cmd;
 };
 
-int fork1(void);  // Fork but panics on failure.
+int fork1(void);  /// Fork but panics on failure.
 void panic(char*);
 struct cmd *parsecmd(char*);
 
-// Execute cmd.  Never returns.
+/// Execute cmd.  Never returns.
 void
 runcmd(struct cmd *cmd)
 {
@@ -136,7 +136,7 @@ getcmd(char *buf, int nbuf)
   printf(2, "$ ");
   memset(buf, 0, nbuf);
   gets(buf, nbuf);
-  if(buf[0] == 0) // EOF
+  if(buf[0] == 0) /// EOF
     return -1;
   return 0;
 }
@@ -147,7 +147,7 @@ main(void)
   static char buf[100];
   int fd;
 
-  // Ensure that three file descriptors are open.
+  /// Ensure that three file descriptors are open.
   while((fd = open("console", O_RDWR)) >= 0){
     if(fd >= 3){
       close(fd);
@@ -155,11 +155,11 @@ main(void)
     }
   }
 
-  // Read and run input commands.
+  /// Read and run input commands.
   while(getcmd(buf, sizeof(buf)) >= 0){
     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
-      // Chdir must be called by the parent, not the child.
-      buf[strlen(buf)-1] = 0;  // chop \n
+      /// Chdir must be called by the parent, not the child.
+      buf[strlen(buf)-1] = 0;  /// chop \n
       if(chdir(buf+3) < 0)
         printf(2, "cannot cd %s\n", buf+3);
       continue;
@@ -189,8 +189,8 @@ fork1(void)
   return pid;
 }
 
-//PAGEBREAK!
-// Constructors
+///PAGEBREAK!
+/// Constructors
 
 struct cmd*
 execcmd(void)
@@ -256,8 +256,8 @@ backcmd(struct cmd *subcmd)
   cmd->cmd = subcmd;
   return (struct cmd*)cmd;
 }
-//PAGEBREAK!
-// Parsing
+///PAGEBREAK!
+/// Parsing
 
 char whitespace[] = " \t\r\n\v";
 char symbols[] = "<|>&;()";
@@ -388,7 +388,7 @@ parseredirs(struct cmd *cmd, char **ps, char *es)
     case '>':
       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
       break;
-    case '+':  // >>
+    case '+':  /// >>
       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
       break;
     }
@@ -445,7 +445,7 @@ parseexec(char **ps, char *es)
   return ret;
 }
 
-// NUL-terminate all the counted strings.
+/// NUL-terminate all the counted strings.
 struct cmd*
 nulterminate(struct cmd *cmd)
 {
diff --git a/sleep1.p b/sleep1.p
old mode 100644
new mode 100755
index af69772..80b7152
--- a/sleep1.p
+++ b/sleep1.p
@@ -6,7 +6,7 @@ a model of a simple producer/consumer queue.
 To run:
 	spinp sleep1.p
 
-(You may need to install Spin, available at http://spinroot.com/.)
+(You may need to install Spin, available at http:///spinroot.com/.)
 
 After a successful run spin prints something like:
 
@@ -35,7 +35,7 @@ If this is changed to:
 		i = i + 1;
 
 then a deadlock can happen, because the non-atomic
-increment of value conflicts with the non-atomic 
+increment of value conflicts with the non-atomic
 decrement in consumer, causing value to have a bad value.
 Try this.
 
@@ -97,7 +97,7 @@ inline wakeup()
 active[N] proctype consumer()
 {
 	byte i, x;
-	
+
 	i = 0;
 	do
 	:: i < ITER ->
@@ -116,7 +116,7 @@ active[N] proctype consumer()
 active[N] proctype producer()
 {
 	byte i, x, w;
-	
+
 	i = 0;
 	do
 	:: i < ITER ->
@@ -129,6 +129,6 @@ active[N] proctype producer()
 		break
 	od;
 	i = 0;
-	skip	
+	skip
 }
 
diff --git a/sleeplock.c b/sleeplock.c
old mode 100644
new mode 100755
index e0750ea..34a386e
--- a/sleeplock.c
+++ b/sleeplock.c
@@ -1,4 +1,4 @@
-// Sleeping locks
+/// Sleeping locks
 
 #include "types.h"
 #include "defs.h"
@@ -45,7 +45,7 @@ int
 holdingsleep(struct sleeplock *lk)
 {
   int r;
-  
+
   acquire(&lk->lk);
   r = lk->locked && (lk->pid == myproc()->pid);
   release(&lk->lk);
diff --git a/sleeplock.h b/sleeplock.h
old mode 100644
new mode 100755
index 110e6f3..0bd9944
--- a/sleeplock.h
+++ b/sleeplock.h
@@ -1,10 +1,10 @@
-// Long-term locks for processes
+/// Long-term locks for processes
 struct sleeplock {
-  uint locked;       // Is the lock held?
-  struct spinlock lk; // spinlock protecting this sleep lock
-  
-  // For debugging:
-  char *name;        // Name of lock.
-  int pid;           // Process holding lock
+  uint locked;       /// Is the lock held?
+  struct spinlock lk; /// spinlock protecting this sleep lock
+
+  /// For debugging:
+  char *name;        /// Name of lock.
+  int pid;           /// Process holding lock
 };
 
diff --git a/sock.c b/sock.c
new file mode 100755
index 0000000..ec7c119
--- /dev/null
+++ b/sock.c
@@ -0,0 +1,387 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "spinlock.h"
+#include "sock.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+#include "sockparam.h"
+
+///
+/// TODO: Create a structure to maintain a list of sockets
+/// Should it have locking?
+///
+
+///helpful functions
+
+static void
+bufferCopy(char *s, const char *t, int n){
+  for(int i=0; i<n; i++){
+    s[i] = t[i];
+  }
+}
+
+static void
+bufferClear(char *s){
+  s[0] = 0;
+}
+
+struct {
+  struct spinlock lock;
+  struct sock sockets[NSOCK];
+} stable;
+
+int portToSocketIdxMap[NPORT];
+
+void
+sinit(void)
+{
+  //cprintf("***In sinit()***\n");
+  ///
+  /// TODO: Write any initialization code for socket API
+  /// initialization.
+  ///
+
+  int i;
+
+  ///initializing stable
+  for(i = 0; i < NSOCK; i++){
+    stable.sockets[i].local_port = INVALID_PORT;
+    stable.sockets[i].remote_port = INVALID_PORT;
+    stable.sockets[i].state = CLOSED;
+    stable.sockets[i].owner_pid = INVALID_PID;
+    stable.sockets[i].data_available = FALSE;
+  }
+  initlock(&stable.lock, "stable");
+
+  ///initializing port to socket map
+  for(i = 0; i < NPORT; i++){
+    portToSocketIdxMap[i] = INVALID_SOCKET_INDEX;
+  }
+
+  //cprintf("In sinit(): FINISHED INITIALIZATION\n");
+
+}
+
+int
+listen(int lport) {
+  //cprintf("***In listen()***\n");
+  //cprintf("In listen(): lport = %d\n", lport);
+
+  ///
+  /// TODO: Put the actual implementation of listen here.
+  ///
+
+  ///error check
+  if(portToSocketIdxMap[lport]!=INVALID_SOCKET_INDEX){
+    cprintf("In listen(): PORT ALREADY IN USE\n");
+    return E_INVALID_ARG;
+  }
+
+  acquire(&stable.lock);
+
+  ///finding available local socket
+  int sockIdx = INVALID_SOCKET_INDEX;
+  for(int i=0; i<NSOCK; i++){
+    if(stable.sockets[i].state == CLOSED){
+      sockIdx = i;
+      break;
+    }
+  }
+  //cprintf("In listen(): sockIdx = %d\n", sockIdx);
+
+  if(sockIdx == INVALID_SOCKET_INDEX){
+    cprintf("In listen(): NO USABLE SOCKET AVAILABLE\n");
+    release(&stable.lock);
+    return E_FAIL;
+  }
+
+
+  ///going to listening mode
+  stable.sockets[sockIdx].local_port = lport;
+  stable.sockets[sockIdx].state = LISTENING;
+  stable.sockets[sockIdx].owner_pid = myproc()->pid;
+
+  ///mapping this local port to socket index
+  portToSocketIdxMap[lport] = sockIdx;
+
+  ///remote port not set yet
+  sleep(&stable.sockets[sockIdx], &stable.lock);
+  //cprintf("In listen(): AWAKENED FROM SLEEP!\n");
+
+  //stable.sockets[sockIdx].remote_port = 20;
+
+  if(stable.sockets[sockIdx].remote_port == INVALID_PORT){
+    cprintf("In listen(): REMOTE PORT IS NOT SET!\n");
+    release(&stable.lock);
+    return E_CONNECTION_ERROR;
+  }
+  else{
+    //cprintf("In listen(): REMOTE PORT IS SET TO = %d\n", stable.sockets[sockIdx].remote_port);
+  }
+
+  stable.sockets[sockIdx].state = CONNECTED;
+
+  release(&stable.lock);
+
+  cprintf("In listen(): CONNECTION SUCCESSFULLY ESTABLISHED!\n");
+
+  return SOCKET_OPERATION_SUCCESSFUL;
+
+
+}
+
+int
+connect(int rport, const char* host) {
+  //cprintf("***In connect()***\n");
+  //cprintf("In connect(): rport = %d\n", rport);
+  //cprintf("In connect(): host = %s\n", host);
+
+  ///
+  /// TODO: Put the actual implementation of connect here.
+  ///
+
+
+  ///error check
+  if(portToSocketIdxMap[rport]==INVALID_SOCKET_INDEX){
+    cprintf("In connect(): PORT NOT IN USE\n");
+    return E_INVALID_ARG;
+  }
+
+  acquire(&stable.lock);
+
+  ///finding available local port
+  int lport = INVALID_PORT;
+  for(int i=0; i<NPORT; i++){
+    if(portToSocketIdxMap[i]==INVALID_SOCKET_INDEX){
+      lport = i;
+      break;
+    }
+  }
+  //cprintf("In connect(): lport = %d\n", lport);
+
+  if(lport == INVALID_PORT){
+    cprintf("In connect(): NO USABLE PORT AVAILABLE\n");
+    release(&stable.lock);
+    return E_FAIL;
+  }
+
+
+  ///finding available local socket
+  int sockIdx = INVALID_SOCKET_INDEX;
+  for(int i=0; i<NSOCK; i++){
+    if(stable.sockets[i].state == CLOSED){
+      sockIdx = i;
+      break;
+    }
+  }
+  //cprintf("In connect(): sockIdx = %d\n", sockIdx);
+
+  if(sockIdx == INVALID_SOCKET_INDEX){
+    cprintf("In connect(): NO USABLE SOCKET AVAILABLE\n");
+    release(&stable.lock);
+    return E_FAIL;
+  }
+
+
+  ///finding server socket
+  int remoteSockIdx = portToSocketIdxMap[rport];
+  //cprintf("In connect(): remoteSockIdx = %d\n", remoteSockIdx);
+
+  if(remoteSockIdx == INVALID_SOCKET_INDEX){
+    cprintf("In connect(): INVALID SERVER SOCKET\n");
+    release(&stable.lock);
+    return E_NOTFOUND;
+  }
+  else if(stable.sockets[remoteSockIdx].state != LISTENING){
+    cprintf("In connect(): INVALID SERVER STATE\n");
+    return E_WRONG_STATE;
+  }
+
+  ///configuring local socket
+  stable.sockets[sockIdx].local_port = lport;
+  stable.sockets[sockIdx].remote_port = rport;
+  stable.sockets[sockIdx].state = CONNECTED;
+  stable.sockets[sockIdx].owner_pid = myproc()->pid;
+
+  portToSocketIdxMap[lport] = sockIdx;
+
+
+  ///writing lport to rport of server socket and awake it
+  stable.sockets[remoteSockIdx].remote_port = lport;
+
+  wakeup(&stable.sockets[remoteSockIdx]);
+
+  release(&stable.lock);
+
+  cprintf("In connect(): CONNECTION SUCCESSFULLY ESTABLISHED!\n");
+
+  return lport;
+}
+
+int
+send(int lport, const char* data, int n) {
+  //cprintf("***In send()***\n");
+  //cprintf("In send():  port = %d\n", lport);
+  //cprintf("In send():  data = %s\n", data);
+  //cprintf("In send():  n = %d\n", n);
+
+  ///
+  /// TODO: Put the actual implementation of send here.
+  ///
+
+  acquire(&stable.lock);
+
+  ///validating local socket
+  int sockIdx = portToSocketIdxMap[lport];
+  if(sockIdx == INVALID_SOCKET_INDEX){
+      cprintf("In send(): INVALID LOCAL SOCKET\n");
+      release(&stable.lock);
+      return E_NOTFOUND;
+  }
+  else if(stable.sockets[sockIdx].owner_pid != myproc()->pid){
+    cprintf("In send(): INVALID OWNER PROCESS\n");
+    release(&stable.lock);
+    return E_ACCESS_DENIED;
+  }
+  else if(stable.sockets[sockIdx].state != CONNECTED){
+    cprintf("In send(): INVALID SOCKET STATE\n");
+    release(&stable.lock);
+    return E_WRONG_STATE;
+  }
+
+
+  ///validating remote port
+  int rport = stable.sockets[sockIdx].remote_port;
+   if(rport == INVALID_PORT){
+    cprintf("In send(): REMOTE PORT IS NOT SET!\n");
+    release(&stable.lock);
+    return E_CONNECTION_ERROR;
+  }
+
+  ///validating remote socket
+  int remoteSockIdx = portToSocketIdxMap[rport];
+  //cprintf("In send(): remoteSockIdx = %d\n", remoteSockIdx);
+
+  if(remoteSockIdx == INVALID_SOCKET_INDEX){
+    cprintf("In send(): INVALID REMOTE SOCKET\n");
+    release(&stable.lock);
+    return E_NOTFOUND;
+  }
+  else if(stable.sockets[remoteSockIdx].state != CONNECTED){
+    cprintf("In send(): INVALID REMOTE STATE\n");
+    release(&stable.lock);
+    return E_WRONG_STATE;
+  }
+
+  if(stable.sockets[remoteSockIdx].data_available == TRUE){ //wait for the buffer to be cleared
+    sleep(&stable.sockets[remoteSockIdx], &stable.lock);
+    //cprintf("In send(): AWAKENED FROM SLEEP!\n");
+  }
+
+  bufferCopy(stable.sockets[remoteSockIdx].buffer, data, n);
+  stable.sockets[remoteSockIdx].data_available = TRUE;
+
+  wakeup(&stable.sockets[remoteSockIdx]);
+
+  release(&stable.lock);
+
+  //cprintf("In send(): DATA SUCCESSFULLY SENT!\n");
+
+  return SOCKET_OPERATION_SUCCESSFUL;
+}
+
+
+int
+recv(int lport, char* data, int n) {
+  //cprintf("***In recv()***\n");
+  //cprintf("In recv():  port = %d\n", lport);
+  //cprintf("In recv():  n = %d\n", n);
+
+  ///
+  /// TODO: Put the actual implementation of recv here.
+  ///
+
+  acquire(&stable.lock);
+
+  ///validating local socket
+  int sockIdx = portToSocketIdxMap[lport];
+  if(sockIdx == INVALID_SOCKET_INDEX){
+      cprintf("In recv(): INVALID LOCAL SOCKET\n");
+      release(&stable.lock);
+      return E_NOTFOUND;
+  }
+  else if(stable.sockets[sockIdx].owner_pid != myproc()->pid){
+    cprintf("In recv(): INVALID OWNER PROCESS\n");
+    release(&stable.lock);
+    return E_ACCESS_DENIED;
+  }
+  else if(stable.sockets[sockIdx].state != CONNECTED){
+    cprintf("In recv(): INVALID SOCKET STATE\n");
+    release(&stable.lock);
+    return E_WRONG_STATE;
+  }
+
+
+  if(stable.sockets[sockIdx].data_available == FALSE){ //wait for the buffer to be written
+    sleep(&stable.sockets[sockIdx], &stable.lock);
+    //cprintf("In recv(): AWAKENED FROM SLEEP!\n");
+  }
+
+  bufferCopy(data, stable.sockets[sockIdx].buffer, n);
+
+  bufferClear(stable.sockets[sockIdx].buffer);
+  stable.sockets[sockIdx].data_available = FALSE;
+
+
+  wakeup(&stable.sockets[sockIdx]);
+
+  release(&stable.lock);
+
+  //cprintf("In recv(): DATA SUCCESSFULLY RECEIVED! : %s\n", data);
+
+  return SOCKET_OPERATION_SUCCESSFUL;
+
+}
+
+int
+disconnect(int lport) {
+  //cprintf("***In disconnect()***\n");
+  //cprintf("In disconnect(): lport = %d\n", lport);
+
+  ///
+  /// TODO: Put the actual implementation of disconnect here.
+  ///
+
+  acquire(&stable.lock);
+
+  ///error check
+  int sockIdx = portToSocketIdxMap[lport];
+  if(portToSocketIdxMap[lport]==INVALID_SOCKET_INDEX || stable.sockets[sockIdx].state != CONNECTED){
+    cprintf("In disconnect(): INVALID PORT or SOCKET STATE\n");
+    release(&stable.lock);
+    return E_NOTFOUND;
+  }
+  else if(stable.sockets[sockIdx].owner_pid != myproc()->pid){
+    cprintf("In disconnect(): INVALID OWNER PROCESS\n");
+    release(&stable.lock);
+    return E_ACCESS_DENIED;
+  }
+
+  stable.sockets[sockIdx].local_port = INVALID_PORT;
+  stable.sockets[sockIdx].remote_port = INVALID_PORT;
+  stable.sockets[sockIdx].state = CLOSED;
+  stable.sockets[sockIdx].owner_pid = INVALID_PID;
+  bufferClear(stable.sockets[sockIdx].buffer);
+  stable.sockets[sockIdx].data_available = FALSE;
+
+  portToSocketIdxMap[lport] = INVALID_SOCKET_INDEX;
+
+   release(&stable.lock);
+
+  //cprintf("In disconnect(): SUCCESSFULLY DISCONNECTED!\n");
+
+  return SOCKET_OPERATION_SUCCESSFUL;
+}
diff --git a/sock.h b/sock.h
new file mode 100755
index 0000000..717b45e
--- /dev/null
+++ b/sock.h
@@ -0,0 +1,22 @@
+///done
+
+///======================================================
+/// TODO: Define an enumeration to represent socket state
+///======================================================
+enum sockstate { CLOSED, LISTENING, CONNECTED };
+enum boolean { TRUE, FALSE };
+
+///===============================================
+/// TODO: Define a structure to represent a socket
+///===============================================
+
+struct sock {
+  int local_port;
+  int remote_port;
+  enum sockstate state;        ///socket state
+  int owner_pid;                     ///owner Process ID
+  char buffer[SOCKET_BUFFER_SIZE+5];
+  enum boolean data_available;  ///boolean: TRUE or FALSE
+
+
+};
diff --git a/sockparam.h b/sockparam.h
new file mode 100755
index 0000000..8b2a0f2
--- /dev/null
+++ b/sockparam.h
@@ -0,0 +1,19 @@
+///=========================================================================
+///PARAMETERS
+///=========================================================================
+#define INVALID_SOCKET_INDEX -99
+#define INVALID_PORT -88
+#define INVALID_PID -77
+
+#define SOCKET_OPERATION_SUCCESSFUL 0
+
+
+///==========================================================================
+///ERRORS
+///==========================================================================
+#define E_NOTFOUND      -1025 ///Accessing a socket that is not in the stable
+#define E_ACCESS_DENIED -1026 ///Accessing a socket from wrong process
+#define E_WRONG_STATE   -1027 ///Attempts to send or receive, when the socket is not connected
+#define E_FAIL          -1028 ///If no more socket can be opened (limit exceeded)
+#define E_INVALID_ARG   -1029 ///Parameter issues
+#define E_CONNECTION_ERROR -1030
diff --git a/socktest.c b/socktest.c
new file mode 100755
index 0000000..d7ec900
--- /dev/null
+++ b/socktest.c
@@ -0,0 +1,77 @@
+#include "types.h"
+#include "user.h"
+
+int serverPort = 10;
+
+void clientProc() {
+  int clientPort;
+  char buf[128];
+  char host[16] = "localhost";
+
+  /// sleep for 100 clock ticks to ensure that the server process starts first.
+  sleep(100);
+
+  printf(1, "Client>> Attempting to connect to port %d, host %s ...\n", serverPort, host);
+  clientPort = connect(serverPort, host);
+  sleep(20);
+  printf(1, "Client>> connect() returned %d\n", clientPort);
+
+  while (1) {
+    printf(1, "Client>> Enter text to send to server: ");
+    gets(buf, sizeof(buf));
+    buf[strlen(buf) - 1] = '\0'; /// Eliminating the '\n'
+    send(clientPort, buf, strlen(buf) + 1);
+
+    if (0 == strcmp(buf, "exit")) {
+      printf(1, "Client exiting...\n");
+      disconnect(clientPort);
+      break;
+    }
+
+    sleep(100 + uptime() % 100);
+
+    recv(clientPort, buf, sizeof(buf));
+    printf(1, "Client>> Received: \"%s\"\n", buf);
+  }
+}
+
+void serverProc() {
+  int status;
+  char buf[128];
+
+  printf(1, "Server>> Starting to listen at port %d ...\n", serverPort);
+  status = listen(serverPort);
+  printf(1, "Server>> listen() returned %d\n", status);
+
+  while (1) {
+    sleep(100 + uptime() % 100);
+
+    recv(serverPort, buf, sizeof(buf));
+    printf(1, "Server>> Received: \"%s\"\n", buf);
+
+    if (0 == strcmp(buf, "exit")) {
+      printf(1, "Server exiting...\n");
+      disconnect(serverPort);
+      break;
+    }
+
+    sleep(100 + uptime() % 100);
+
+    strcpy(buf+strlen(buf), " OK");
+    send(serverPort, buf, strlen(buf) + 1);
+  }
+}
+
+
+int main(int argc, char *argv[])
+{
+  if (0 == fork()) {
+    clientProc();
+    exit();
+  } else {
+    serverProc();
+    /// This is the parent process. So, it needs to wait before client terminates
+    wait();
+    exit();
+  }
+}
diff --git a/spinlock.c b/spinlock.c
old mode 100644
new mode 100755
index 4020186..5a08083
--- a/spinlock.c
+++ b/spinlock.c
@@ -1,4 +1,4 @@
-// Mutual exclusion spin locks.
+/// Mutual exclusion spin locks.
 
 #include "types.h"
 #include "defs.h"
@@ -17,32 +17,32 @@ initlock(struct spinlock *lk, char *name)
   lk->cpu = 0;
 }
 
-// Acquire the lock.
-// Loops (spins) until the lock is acquired.
-// Holding a lock for a long time may cause
-// other CPUs to waste time spinning to acquire it.
+/// Acquire the lock.
+/// Loops (spins) until the lock is acquired.
+/// Holding a lock for a long time may cause
+/// other CPUs to waste time spinning to acquire it.
 void
 acquire(struct spinlock *lk)
 {
-  pushcli(); // disable interrupts to avoid deadlock.
+  pushcli(); /// disable interrupts to avoid deadlock.
   if(holding(lk))
     panic("acquire");
 
-  // The xchg is atomic.
+  /// The xchg is atomic.
   while(xchg(&lk->locked, 1) != 0)
     ;
 
-  // Tell the C compiler and the processor to not move loads or stores
-  // past this point, to ensure that the critical section's memory
-  // references happen after the lock is acquired.
+  /// Tell the C compiler and the processor to not move loads or stores
+  /// past this point, to ensure that the critical section's memory
+  /// references happen after the lock is acquired.
   __sync_synchronize();
 
-  // Record info about lock acquisition for debugging.
+  /// Record info about lock acquisition for debugging.
   lk->cpu = mycpu();
   getcallerpcs(&lk, lk->pcs);
 }
 
-// Release the lock.
+/// Release the lock.
 void
 release(struct spinlock *lk)
 {
@@ -52,22 +52,22 @@ release(struct spinlock *lk)
   lk->pcs[0] = 0;
   lk->cpu = 0;
 
-  // Tell the C compiler and the processor to not move loads or stores
-  // past this point, to ensure that all the stores in the critical
-  // section are visible to other cores before the lock is released.
-  // Both the C compiler and the hardware may re-order loads and
-  // stores; __sync_synchronize() tells them both not to.
+  /// Tell the C compiler and the processor to not move loads or stores
+  /// past this point, to ensure that all the stores in the critical
+  /// section are visible to other cores before the lock is released.
+  /// Both the C compiler and the hardware may re-order loads and
+  /// stores; __sync_synchronize() tells them both not to.
   __sync_synchronize();
 
-  // Release the lock, equivalent to lk->locked = 0.
-  // This code can't use a C assignment, since it might
-  // not be atomic. A real OS would use C atomics here.
+  /// Release the lock, equivalent to lk->locked = 0.
+  /// This code can't use a C assignment, since it might
+  /// not be atomic. A real OS would use C atomics here.
   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
 
   popcli();
 }
 
-// Record the current call stack in pcs[] by following the %ebp chain.
+/// Record the current call stack in pcs[] by following the %ebp chain.
 void
 getcallerpcs(void *v, uint pcs[])
 {
@@ -78,14 +78,14 @@ getcallerpcs(void *v, uint pcs[])
   for(i = 0; i < 10; i++){
     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
       break;
-    pcs[i] = ebp[1];     // saved %eip
-    ebp = (uint*)ebp[0]; // saved %ebp
+    pcs[i] = ebp[1];     /// saved %eip
+    ebp = (uint*)ebp[0]; /// saved %ebp
   }
   for(; i < 10; i++)
     pcs[i] = 0;
 }
 
-// Check whether this cpu is holding the lock.
+/// Check whether this cpu is holding the lock.
 int
 holding(struct spinlock *lock)
 {
@@ -97,9 +97,9 @@ holding(struct spinlock *lock)
 }
 
 
-// Pushcli/popcli are like cli/sti except that they are matched:
-// it takes two popcli to undo two pushcli.  Also, if interrupts
-// are off, then pushcli, popcli leaves them off.
+/// Pushcli/popcli are like cli/sti except that they are matched:
+/// it takes two popcli to undo two pushcli.  Also, if interrupts
+/// are off, then pushcli, popcli leaves them off.
 
 void
 pushcli(void)
diff --git a/spinlock.h b/spinlock.h
old mode 100644
new mode 100755
index 0a9d8e2..b08928b
--- a/spinlock.h
+++ b/spinlock.h
@@ -1,11 +1,11 @@
-// Mutual exclusion lock.
+/// Mutual exclusion lock.
 struct spinlock {
-  uint locked;       // Is the lock held?
+  uint locked;       /// Is the lock held?
 
-  // For debugging:
-  char *name;        // Name of lock.
-  struct cpu *cpu;   // The cpu holding the lock.
-  uint pcs[10];      // The call stack (an array of program counters)
-                     // that locked the lock.
+  /// For debugging:
+  char *name;        /// Name of lock.
+  struct cpu *cpu;   /// The cpu holding the lock.
+  uint pcs[10];      /// The call stack (an array of program counters)
+                     /// that locked the lock.
 };
 
diff --git a/stat.h b/stat.h
old mode 100644
new mode 100755
index 8a80933..cca4dfb
--- a/stat.h
+++ b/stat.h
@@ -1,11 +1,11 @@
-#define T_DIR  1   // Directory
-#define T_FILE 2   // File
-#define T_DEV  3   // Device
+#define T_DIR  1   /// Directory
+#define T_FILE 2   /// File
+#define T_DEV  3   /// Device
 
 struct stat {
-  short type;  // Type of file
-  int dev;     // File system's disk device
-  uint ino;    // Inode number
-  short nlink; // Number of links to file
-  uint size;   // Size of file in bytes
+  short type;  /// Type of file
+  int dev;     /// File system's disk device
+  uint ino;    /// Inode number
+  short nlink; /// Number of links to file
+  uint size;   /// Size of file in bytes
 };
diff --git a/stressfs.c b/stressfs.c
old mode 100644
new mode 100755
index c0a4743..a0f366b
--- a/stressfs.c
+++ b/stressfs.c
@@ -1,11 +1,11 @@
-// Demonstrate that moving the "acquire" in iderw after the loop that
-// appends to the idequeue results in a race.
+/// Demonstrate that moving the "acquire" in iderw after the loop that
+/// appends to the idequeue results in a race.
 
-// For this to work, you should also add a spin within iderw's
-// idequeue traversal loop.  Adding the following demonstrated a panic
-// after about 5 runs of stressfs in QEMU on a 2.1GHz CPU:
-//    for (i = 0; i < 40000; i++)
-//      asm volatile("");
+/// For this to work, you should also add a spin within iderw's
+/// idequeue traversal loop.  Adding the following demonstrated a panic
+/// after about 5 runs of stressfs in QEMU on a 2.1GHz CPU:
+///    for (i = 0; i < 40000; i++)
+///      asm volatile("");
 
 #include "types.h"
 #include "stat.h"
@@ -32,7 +32,7 @@ main(int argc, char *argv[])
   path[8] += i;
   fd = open(path, O_CREATE | O_RDWR);
   for(i = 0; i < 20; i++)
-//    printf(fd, "%d\n", i);
+///    printf(fd, "%d\n", i);
     write(fd, data, sizeof(data));
   close(fd);
 
diff --git a/string.c b/string.c
old mode 100644
new mode 100755
index a7cc61f..792008e
--- a/string.c
+++ b/string.c
@@ -48,7 +48,7 @@ memmove(void *dst, const void *src, uint n)
   return dst;
 }
 
-// memcpy exists to placate GCC.  Use memmove.
+/// memcpy exists to placate GCC.  Use memmove.
 void*
 memcpy(void *dst, const void *src, uint n)
 {
@@ -78,7 +78,7 @@ strncpy(char *s, const char *t, int n)
   return os;
 }
 
-// Like strncpy but guaranteed to NUL-terminate.
+/// Like strncpy but guaranteed to NUL-terminate.
 char*
 safestrcpy(char *s, const char *t, int n)
 {
diff --git a/swtch.S b/swtch.S
old mode 100644
new mode 100755
diff --git a/syscall.c b/syscall.c
old mode 100644
new mode 100755
index ee85261..d6f1d42
--- a/syscall.c
+++ b/syscall.c
@@ -7,13 +7,13 @@
 #include "x86.h"
 #include "syscall.h"
 
-// User code makes a system call with INT T_SYSCALL.
-// System call number in %eax.
-// Arguments on the stack, from the user call to the C
-// library system call function. The saved user %esp points
-// to a saved program counter, and then the first argument.
+/// User code makes a system call with INT T_SYSCALL.
+/// System call number in %eax.
+/// Arguments on the stack, from the user call to the C
+/// library system call function. The saved user %esp points
+/// to a saved program counter, and then the first argument.
 
-// Fetch the int at addr from the current process.
+/// Fetch the int at addr from the current process.
 int
 fetchint(uint addr, int *ip)
 {
@@ -25,9 +25,9 @@ fetchint(uint addr, int *ip)
   return 0;
 }
 
-// Fetch the nul-terminated string at addr from the current process.
-// Doesn't actually copy the string - just sets *pp to point at it.
-// Returns length of string, not including nul.
+/// Fetch the nul-terminated string at addr from the current process.
+/// Doesn't actually copy the string - just sets *pp to point at it.
+/// Returns length of string, not including nul.
 int
 fetchstr(uint addr, char **pp)
 {
@@ -45,22 +45,22 @@ fetchstr(uint addr, char **pp)
   return -1;
 }
 
-// Fetch the nth 32-bit system call argument.
+/// Fetch the nth 32-bit system call argument.
 int
 argint(int n, int *ip)
 {
   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
 }
 
-// Fetch the nth word-sized system call argument as a pointer
-// to a block of memory of size bytes.  Check that the pointer
-// lies within the process address space.
+/// Fetch the nth word-sized system call argument as a pointer
+/// to a block of memory of size bytes.  Check that the pointer
+/// lies within the process address space.
 int
 argptr(int n, char **pp, int size)
 {
   int i;
   struct proc *curproc = myproc();
- 
+
   if(argint(n, &i) < 0)
     return -1;
   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
@@ -69,10 +69,10 @@ argptr(int n, char **pp, int size)
   return 0;
 }
 
-// Fetch the nth word-sized system call argument as a string pointer.
-// Check that the pointer is valid and the string is nul-terminated.
-// (There is no shared writable memory, so the string can't change
-// between this check and being used by the kernel.)
+/// Fetch the nth word-sized system call argument as a string pointer.
+/// Check that the pointer is valid and the string is nul-terminated.
+/// (There is no shared writable memory, so the string can't change
+/// between this check and being used by the kernel.)
 int
 argstr(int n, char **pp)
 {
@@ -103,6 +103,11 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_listen(void);
+extern int sys_connect(void);
+extern int sys_send(void);
+extern int sys_recv(void);
+extern int sys_disconnect(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +131,11 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_listen]  sys_listen,
+[SYS_connect] sys_connect,
+[SYS_send]    sys_send,
+[SYS_recv]    sys_recv,
+[SYS_disconnect] sys_disconnect
 };
 
 void
diff --git a/syscall.h b/syscall.h
old mode 100644
new mode 100755
index bc5f356..8eba768
--- a/syscall.h
+++ b/syscall.h
@@ -1,4 +1,4 @@
-// System call numbers
+/// System call numbers
 #define SYS_fork    1
 #define SYS_exit    2
 #define SYS_wait    3
@@ -20,3 +20,8 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_listen  22
+#define SYS_connect  23
+#define SYS_send  24
+#define SYS_recv  25
+#define SYS_disconnect  26
diff --git a/sysfile.c b/sysfile.c
old mode 100644
new mode 100755
index 87e508b..3e067fb
--- a/sysfile.c
+++ b/sysfile.c
@@ -1,8 +1,8 @@
-//
-// File-system system calls.
-// Mostly argument checking, since we don't trust
-// user code, and calls into file.c and fs.c.
-//
+///
+/// File-system system calls.
+/// Mostly argument checking, since we don't trust
+/// user code, and calls into file.c and fs.c.
+///
 
 #include "types.h"
 #include "defs.h"
@@ -16,8 +16,8 @@
 #include "file.h"
 #include "fcntl.h"
 
-// Fetch the nth word-sized system call argument as a file descriptor
-// and return both the descriptor and the corresponding struct file.
+/// Fetch the nth word-sized system call argument as a file descriptor
+/// and return both the descriptor and the corresponding struct file.
 static int
 argfd(int n, int *pfd, struct file **pf)
 {
@@ -35,8 +35,8 @@ argfd(int n, int *pfd, struct file **pf)
   return 0;
 }
 
-// Allocate a file descriptor for the given file.
-// Takes over file reference from caller on success.
+/// Allocate a file descriptor for the given file.
+/// Takes over file reference from caller on success.
 static int
 fdalloc(struct file *f)
 {
@@ -114,7 +114,7 @@ sys_fstat(void)
   return filestat(f, st);
 }
 
-// Create the path new as a link to the same inode as old.
+/// Create the path new as a link to the same inode as old.
 int
 sys_link(void)
 {
@@ -164,7 +164,7 @@ bad:
   return -1;
 }
 
-// Is the directory dp empty except for "." and ".." ?
+/// Is the directory dp empty except for "." and ".." ?
 static int
 isdirempty(struct inode *dp)
 {
@@ -180,7 +180,7 @@ isdirempty(struct inode *dp)
   return 1;
 }
 
-//PAGEBREAK!
+///PAGEBREAK!
 int
 sys_unlink(void)
 {
@@ -200,7 +200,7 @@ sys_unlink(void)
 
   ilock(dp);
 
-  // Cannot unlink "." or "..".
+  /// Cannot unlink "." or "..".
   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
     goto bad;
 
@@ -267,10 +267,10 @@ create(char *path, short type, short major, short minor)
   ip->nlink = 1;
   iupdate(ip);
 
-  if(type == T_DIR){  // Create . and .. entries.
-    dp->nlink++;  // for ".."
+  if(type == T_DIR){  /// Create . and .. entries.
+    dp->nlink++;  /// for ".."
     iupdate(dp);
-    // No ip->nlink++ for ".": avoid cyclic ref count.
+    /// No ip->nlink++ for ".": avoid cyclic ref count.
     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
       panic("create dots");
   }
@@ -375,7 +375,7 @@ sys_chdir(void)
   char *path;
   struct inode *ip;
   struct proc *curproc = myproc();
-  
+
   begin_op();
   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
     end_op();
diff --git a/sysproc.c b/sysproc.c
old mode 100644
new mode 100755
index 0686d29..765a36d
--- a/sysproc.c
+++ b/sysproc.c
@@ -17,7 +17,7 @@ int
 sys_exit(void)
 {
   exit();
-  return 0;  // not reached
+  return 0;  /// not reached
 }
 
 int
@@ -77,8 +77,8 @@ sys_sleep(void)
   return 0;
 }
 
-// return how many clock tick interrupts have occurred
-// since start.
+/// return how many clock tick interrupts have occurred
+/// since start.
 int
 sys_uptime(void)
 {
diff --git a/syssock.c b/syssock.c
new file mode 100755
index 0000000..0e39871
--- /dev/null
+++ b/syssock.c
@@ -0,0 +1,190 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+#include "sockparam.h"
+
+static int
+mystrcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+}
+
+int
+sys_listen(void)
+{
+  //cprintf("***In sys_listen()***\n");
+
+  int port = 0;
+
+  ///
+  /// TODO: Write your code to get and validate port no.
+  ///
+
+  ///validating port
+  argint(0, &port);
+  //cprintf("In sys_listen():  port = %d\n", port);
+
+  if(port < 0 || port >= NPORT){
+    cprintf("In sys_listen(): INVALID PORT NUMBER\n");
+    return E_INVALID_ARG;
+  }
+
+  return listen(port);
+}
+
+int
+sys_connect(void)
+{
+  //cprintf("***In sys_connect()***\n");
+
+  int port = 0;
+  char *host = 0;
+
+  ///
+  /// TODO: Write your code to get and validate port no., host.
+  /// Allow connection to "localhost" or "127.0.0.1" host only
+  ///
+
+  ///validating port
+  argint(0, &port);
+  //cprintf("In sys_connect(): port = %d\n", port);
+
+  if(port < 0 || port >= NPORT){
+    cprintf("In sys_connect(): INVALID PORT NUMBER\n");
+    return E_INVALID_ARG;
+  }
+
+  ///validating host
+  argstr(1, &host);
+  //cprintf("In sys_connect(): host = %s\n", host);
+
+  if(mystrcmp(host, "localhost")!=0 && mystrcmp(host, "127.0.0.1")!=0){
+    cprintf("In sys_connect(): INVALID HOST ADDRESS\n");
+    return E_INVALID_ARG;
+  }
+
+
+  return connect(port, host);
+}
+
+int
+sys_send(void)
+{
+  //cprintf("***In sys_send()***\n");
+
+  int port = 0;
+  char* buf = 0;
+  int n = 0;
+
+  ///
+  /// TODO: Write your code to get and validate port no., buffer and buffer size
+  ///
+
+  ///validating port
+  argint(0, &port);
+  //cprintf("In sys_send():  port = %d\n", port);
+
+  if(port < 0 || port >= NPORT){
+    cprintf("In sys_send(): INVALID PORT NUMBER\n");
+    return E_INVALID_ARG;
+  }
+
+
+  ///validating buf
+  argptr(1, &buf, sizeof(buf));
+  //cprintf("In sys_send():  buf = %s\n", buf);
+
+  if(buf==0){
+    cprintf("In sys_send(): INVALID BUFFER\n");
+    return E_INVALID_ARG;
+  }
+
+  ///gettiing n
+  argint(2, &n);
+  //cprintf("In sys_send():  n = %d\n", n);
+
+  if(n>SOCKET_BUFFER_SIZE){
+    cprintf("In sys_send(): INVALID NUMBER OF CHARS\n");
+    return E_INVALID_ARG;
+  }
+
+  return send(port, buf, n);
+}
+
+int
+sys_recv(void)
+{
+  //cprintf("***In sys_recv()***\n");
+
+  int port = 0;
+  char* buf = 0;
+  int n = 0;
+
+  ///
+  /// TODO: Write your code to get and validate port no., buffer and buffer size
+  ///
+
+  ///validating port
+  argint(0, &port);
+  //cprintf("In sys_recv():  port = %d\n", port);
+
+  if(port < 0 || port >= NPORT){
+    cprintf("In sys_recv(): INVALID PORT NUMBER\n");
+    return E_INVALID_ARG;
+  }
+
+
+  ///validating buf
+  argptr(1, &buf, sizeof(buf));
+  //cprintf("In sys_recv():  &buf = %d\n", &buf);
+
+  if(buf==0){
+    cprintf("In sys_recv(): INVALID BUFFER\n");
+    return E_INVALID_ARG;
+  }
+
+
+  ///gettiing n
+  argint(2, &n);
+  //cprintf("In sys_recv():  n = %d\n", n);
+  if(n>SOCKET_BUFFER_SIZE){
+    cprintf("In sys_recv(): INVALID NUMBER OF CHARS\n");
+    return E_INVALID_ARG;
+  }
+
+  return recv(port, buf, n);
+}
+
+int
+sys_disconnect(void)
+{
+  //cprintf("***In sys_disconnect()***\n");
+
+  int port = 0;
+
+  ///
+  /// TODO: Write your code to get and validate port no.
+  ///
+
+  argint(0, &port);
+
+  //cprintf("In sys_disconnect():  port = %d\n", port);
+
+  if(port < 0 || port >= NPORT){
+    cprintf("In sys_disconnect():INVALID PORT NUMBER\n");
+    return E_INVALID_ARG;
+  }
+
+  return disconnect(port);
+}
+
+
+
+
+
diff --git a/toc.ftr b/toc.ftr
old mode 100644
new mode 100755
diff --git a/toc.hdr b/toc.hdr
old mode 100644
new mode 100755
diff --git a/trap.c b/trap.c
old mode 100644
new mode 100755
index 41c66eb..af32668
--- a/trap.c
+++ b/trap.c
@@ -8,9 +8,9 @@
 #include "traps.h"
 #include "spinlock.h"
 
-// Interrupt descriptor table (shared by all CPUs).
+/// Interrupt descriptor table (shared by all CPUs).
 struct gatedesc idt[256];
-extern uint vectors[];  // in vectors.S: array of 256 entry pointers
+extern uint vectors[];  /// in vectors.S: array of 256 entry pointers
 struct spinlock tickslock;
 uint ticks;
 
@@ -32,7 +32,7 @@ idtinit(void)
   lidt(idt, sizeof(idt));
 }
 
-//PAGEBREAK: 41
+///PAGEBREAK: 41
 void
 trap(struct trapframe *tf)
 {
@@ -61,7 +61,7 @@ trap(struct trapframe *tf)
     lapiceoi();
     break;
   case T_IRQ0 + IRQ_IDE+1:
-    // Bochs generates spurious IDE1 interrupts.
+    /// Bochs generates spurious IDE1 interrupts.
     break;
   case T_IRQ0 + IRQ_KBD:
     kbdintr();
@@ -78,15 +78,15 @@ trap(struct trapframe *tf)
     lapiceoi();
     break;
 
-  //PAGEBREAK: 13
+  ///PAGEBREAK: 13
   default:
     if(myproc() == 0 || (tf->cs&3) == 0){
-      // In kernel, it must be our mistake.
+      /// In kernel, it must be our mistake.
       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
               tf->trapno, cpuid(), tf->eip, rcr2());
       panic("trap");
     }
-    // In user space, assume process misbehaved.
+    /// In user space, assume process misbehaved.
     cprintf("pid %d %s: trap %d err %d on cpu %d "
             "eip 0x%x addr 0x%x--kill proc\n",
             myproc()->pid, myproc()->name, tf->trapno,
@@ -94,19 +94,19 @@ trap(struct trapframe *tf)
     myproc()->killed = 1;
   }
 
-  // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running
-  // until it gets to the regular system call return.)
+  /// Force process exit if it has been killed and is in user space.
+  /// (If it is still executing in the kernel, let it keep running
+  /// until it gets to the regular system call return.)
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
     exit();
 
-  // Force process to give up CPU on clock tick.
-  // If interrupts were on while locks held, would need to check nlock.
+  /// Force process to give up CPU on clock tick.
+  /// If interrupts were on while locks held, would need to check nlock.
   if(myproc() && myproc()->state == RUNNING &&
      tf->trapno == T_IRQ0+IRQ_TIMER)
     yield();
 
-  // Check if the process has been killed since we yielded
+  /// Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
     exit();
 }
diff --git a/trapasm.S b/trapasm.S
old mode 100644
new mode 100755
diff --git a/traps.h b/traps.h
old mode 100644
new mode 100755
index 0bd1fd8..cafb49f
--- a/traps.h
+++ b/traps.h
@@ -1,33 +1,33 @@
-// x86 trap and interrupt constants.
+/// x86 trap and interrupt constants.
 
-// Processor-defined:
-#define T_DIVIDE         0      // divide error
-#define T_DEBUG          1      // debug exception
-#define T_NMI            2      // non-maskable interrupt
-#define T_BRKPT          3      // breakpoint
-#define T_OFLOW          4      // overflow
-#define T_BOUND          5      // bounds check
-#define T_ILLOP          6      // illegal opcode
-#define T_DEVICE         7      // device not available
-#define T_DBLFLT         8      // double fault
-// #define T_COPROC      9      // reserved (not used since 486)
-#define T_TSS           10      // invalid task switch segment
-#define T_SEGNP         11      // segment not present
-#define T_STACK         12      // stack exception
-#define T_GPFLT         13      // general protection fault
-#define T_PGFLT         14      // page fault
-// #define T_RES        15      // reserved
-#define T_FPERR         16      // floating point error
-#define T_ALIGN         17      // aligment check
-#define T_MCHK          18      // machine check
-#define T_SIMDERR       19      // SIMD floating point error
+/// Processor-defined:
+#define T_DIVIDE         0      /// divide error
+#define T_DEBUG          1      /// debug exception
+#define T_NMI            2      /// non-maskable interrupt
+#define T_BRKPT          3      /// breakpoint
+#define T_OFLOW          4      /// overflow
+#define T_BOUND          5      /// bounds check
+#define T_ILLOP          6      /// illegal opcode
+#define T_DEVICE         7      /// device not available
+#define T_DBLFLT         8      /// double fault
+/// #define T_COPROC      9      /// reserved (not used since 486)
+#define T_TSS           10      /// invalid task switch segment
+#define T_SEGNP         11      /// segment not present
+#define T_STACK         12      /// stack exception
+#define T_GPFLT         13      /// general protection fault
+#define T_PGFLT         14      /// page fault
+/// #define T_RES        15      /// reserved
+#define T_FPERR         16      /// floating point error
+#define T_ALIGN         17      /// aligment check
+#define T_MCHK          18      /// machine check
+#define T_SIMDERR       19      /// SIMD floating point error
 
-// These are arbitrarily chosen, but with care not to overlap
-// processor defined exceptions or interrupt vectors.
-#define T_SYSCALL       64      // system call
-#define T_DEFAULT      500      // catchall
+/// These are arbitrarily chosen, but with care not to overlap
+/// processor defined exceptions or interrupt vectors.
+#define T_SYSCALL       64      /// system call
+#define T_DEFAULT      500      /// catchall
 
-#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
+#define T_IRQ0          32      /// IRQ 0 corresponds to int T_IRQ
 
 #define IRQ_TIMER        0
 #define IRQ_KBD          1
diff --git a/types.h b/types.h
old mode 100644
new mode 100755
diff --git a/uart.c b/uart.c
old mode 100644
new mode 100755
index b8946da..c484d7b
--- a/uart.c
+++ b/uart.c
@@ -1,4 +1,4 @@
-// Intel 8250 serial port (UART).
+/// Intel 8250 serial port (UART).
 
 #include "types.h"
 #include "defs.h"
@@ -14,36 +14,36 @@
 
 #define COM1    0x3f8
 
-static int uart;    // is there a uart?
+static int uart;    /// is there a uart?
 
 void
 uartinit(void)
 {
   char *p;
 
-  // Turn off the FIFO
+  /// Turn off the FIFO
   outb(COM1+2, 0);
 
-  // 9600 baud, 8 data bits, 1 stop bit, parity off.
-  outb(COM1+3, 0x80);    // Unlock divisor
+  /// 9600 baud, 8 data bits, 1 stop bit, parity off.
+  outb(COM1+3, 0x80);    /// Unlock divisor
   outb(COM1+0, 115200/9600);
   outb(COM1+1, 0);
-  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
+  outb(COM1+3, 0x03);    /// Lock divisor, 8 data bits.
   outb(COM1+4, 0);
-  outb(COM1+1, 0x01);    // Enable receive interrupts.
+  outb(COM1+1, 0x01);    /// Enable receive interrupts.
 
-  // If status is 0xFF, no serial port.
+  /// If status is 0xFF, no serial port.
   if(inb(COM1+5) == 0xFF)
     return;
   uart = 1;
 
-  // Acknowledge pre-existing interrupt conditions;
-  // enable interrupts.
+  /// Acknowledge pre-existing interrupt conditions;
+  /// enable interrupts.
   inb(COM1+2);
   inb(COM1+0);
   ioapicenable(IRQ_COM1, 0);
 
-  // Announce that we're here.
+  /// Announce that we're here.
   for(p="xv6...\n"; *p; p++)
     uartputc(*p);
 }
diff --git a/ulib.c b/ulib.c
old mode 100644
new mode 100755
diff --git a/umalloc.c b/umalloc.c
old mode 100644
new mode 100755
index a7e7d2c..2c041f3
--- a/umalloc.c
+++ b/umalloc.c
@@ -3,8 +3,8 @@
 #include "user.h"
 #include "param.h"
 
-// Memory allocator by Kernighan and Ritchie,
-// The C programming Language, 2nd ed.  Section 8.7.
+/// Memory allocator by Kernighan and Ritchie,
+/// The C programming Language, 2nd ed.  Section 8.7.
 
 typedef long Align;
 
diff --git a/user.h b/user.h
old mode 100644
new mode 100755
index 4f99c52..9a8489e
--- a/user.h
+++ b/user.h
@@ -1,7 +1,7 @@
 struct stat;
 struct rtcdate;
 
-// system calls
+/// system calls
 int fork(void);
 int exit(void) __attribute__((noreturn));
 int wait(void);
@@ -23,8 +23,13 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int listen(int);
+int connect(int, const char* host);
+int send(int, const char*, int);
+int recv(int, char*, int);
+int disconnect(int);
 
-// ulib.c
+/// ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
 void *memmove(void*, const void*, int);
diff --git a/usertests.c b/usertests.c
old mode 100644
new mode 100755
index a1e97e7..2338dea
--- a/usertests.c
+++ b/usertests.c
@@ -13,7 +13,7 @@ char name[3];
 char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
 int stdout = 1;
 
-// does chdir() call iput(p->cwd) in a transaction?
+/// does chdir() call iput(p->cwd) in a transaction?
 void
 iputtest(void)
 {
@@ -38,7 +38,7 @@ iputtest(void)
   printf(stdout, "iput test ok\n");
 }
 
-// does exit() call iput(p->cwd) in a transaction?
+/// does exit() call iput(p->cwd) in a transaction?
 void
 exitiputtest(void)
 {
@@ -70,17 +70,17 @@ exitiputtest(void)
   printf(stdout, "exitiput test ok\n");
 }
 
-// does the error path in open() for attempt to write a
-// directory call iput() in a transaction?
-// needs a hacked kernel that pauses just after the namei()
-// call in sys_open():
-//    if((ip = namei(path)) == 0)
-//      return -1;
-//    {
-//      int i;
-//      for(i = 0; i < 10000; i++)
-//        yield();
-//    }
+/// does the error path in open() for attempt to write a
+/// directory call iput() in a transaction?
+/// needs a hacked kernel that pauses just after the namei()
+/// call in sys_open():
+///    if((ip = namei(path)) == 0)
+///      return -1;
+///    {
+///      int i;
+///      for(i = 0; i < 10000; i++)
+///        yield();
+///    }
 void
 openiputtest(void)
 {
@@ -113,7 +113,7 @@ openiputtest(void)
   printf(stdout, "openiput test ok\n");
 }
 
-// simple file system tests
+/// simple file system tests
 
 void
 opentest(void)
@@ -300,7 +300,7 @@ exectest(void)
   }
 }
 
-// simple fork and pipe read/write
+/// simple fork and pipe read/write
 
 void
 pipe1(void)
@@ -354,7 +354,7 @@ pipe1(void)
   printf(1, "pipe1 ok\n");
 }
 
-// meant to be run w/ at most two CPUs
+/// meant to be run w/ at most two CPUs
 void
 preempt(void)
 {
@@ -400,7 +400,7 @@ preempt(void)
   printf(1, "preempt ok\n");
 }
 
-// try to find any races between exit and wait
+/// try to find any races between exit and wait
 void
 exitwait(void)
 {
@@ -457,10 +457,10 @@ mem(void)
   }
 }
 
-// More file system tests
+/// More file system tests
 
-// two processes write to the same file descriptor
-// is the offset shared? does inode locking work?
+/// two processes write to the same file descriptor
+/// is the offset shared? does inode locking work?
 void
 sharedfd(void)
 {
@@ -512,8 +512,8 @@ sharedfd(void)
   }
 }
 
-// four processes write different files at the same
-// time, to test block allocation.
+/// four processes write different files at the same
+/// time, to test block allocation.
 void
 fourfiles(void)
 {
@@ -579,7 +579,7 @@ fourfiles(void)
   printf(1, "fourfiles ok\n");
 }
 
-// four processes create and delete different files in same directory
+/// four processes create and delete different files in same directory
 void
 createdelete(void)
 {
@@ -652,7 +652,7 @@ createdelete(void)
   printf(1, "createdelete ok\n");
 }
 
-// can I unlink a file and still read it?
+/// can I unlink a file and still read it?
 void
 unlinkread(void)
 {
@@ -760,7 +760,7 @@ linktest(void)
   printf(1, "linktest ok\n");
 }
 
-// test concurrent create/link/unlink of the same file
+/// test concurrent create/link/unlink of the same file
 void
 concreate(void)
 {
@@ -852,8 +852,8 @@ concreate(void)
   printf(1, "concreate ok\n");
 }
 
-// another concurrent link/unlink/create test,
-// to look for deadlocks.
+/// another concurrent link/unlink/create test,
+/// to look for deadlocks.
 void
 linkunlink()
 {
@@ -888,7 +888,7 @@ linkunlink()
   printf(1, "linkunlink ok\n");
 }
 
-// directory that uses indirect blocks
+/// directory that uses indirect blocks
 void
 bigdir(void)
 {
@@ -1114,7 +1114,7 @@ subdir(void)
   printf(1, "subdir ok\n");
 }
 
-// test writes that are larger than the log.
+/// test writes that are larger than the log.
 void
 bigwrite(void)
 {
@@ -1205,7 +1205,7 @@ fourteen(void)
 {
   int fd;
 
-  // DIRSIZ is 14.
+  /// DIRSIZ is 14.
   printf(1, "fourteen test\n");
 
   if(mkdir("12345678901234") != 0){
@@ -1339,7 +1339,7 @@ dirfile(void)
   printf(1, "dir vs file OK\n");
 }
 
-// test that iput() is called at the end of _namei()
+/// test that iput() is called at the end of _namei()
 void
 iref(void)
 {
@@ -1347,7 +1347,7 @@ iref(void)
 
   printf(1, "empty file name\n");
 
-  // the 50 is NINODE
+  /// the 50 is NINODE
   for(i = 0; i < 50 + 1; i++){
     if(mkdir("irefd") != 0){
       printf(1, "mkdir irefd failed\n");
@@ -1373,9 +1373,9 @@ iref(void)
   printf(1, "empty file name OK\n");
 }
 
-// test that fork fails gracefully
-// the forktest binary also does this, but it runs out of proc entries first.
-// inside the bigger usertests binary, we run out of memory first.
+/// test that fork fails gracefully
+/// the forktest binary also does this, but it runs out of proc entries first.
+/// inside the bigger usertests binary, we run out of memory first.
 void
 forktest(void)
 {
@@ -1421,7 +1421,7 @@ sbrktest(void)
   printf(stdout, "sbrk test\n");
   oldbrk = sbrk(0);
 
-  // can one sbrk() less than a page?
+  /// can one sbrk() less than a page?
   a = sbrk(0);
   int i;
   for(i = 0; i < 5000; i++){
@@ -1448,7 +1448,7 @@ sbrktest(void)
     exit();
   wait();
 
-  // can one grow address space to something big?
+  /// can one grow address space to something big?
 #define BIG (100*1024*1024)
   a = sbrk(0);
   amt = (BIG) - (uint)a;
@@ -1460,7 +1460,7 @@ sbrktest(void)
   lastaddr = (char*) (BIG-1);
   *lastaddr = 99;
 
-  // can one de-allocate?
+  /// can one de-allocate?
   a = sbrk(0);
   c = sbrk(-4096);
   if(c == (char*)0xffffffff){
@@ -1473,7 +1473,7 @@ sbrktest(void)
     exit();
   }
 
-  // can one re-allocate that page?
+  /// can one re-allocate that page?
   a = sbrk(0);
   c = sbrk(4096);
   if(c != a || sbrk(0) != a + 4096){
@@ -1481,7 +1481,7 @@ sbrktest(void)
     exit();
   }
   if(*lastaddr == 99){
-    // should be zero
+    /// should be zero
     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
     exit();
   }
@@ -1493,7 +1493,7 @@ sbrktest(void)
     exit();
   }
 
-  // can we read the kernel's memory?
+  /// can we read the kernel's memory?
   for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
     ppid = getpid();
     pid = fork();
@@ -1509,25 +1509,25 @@ sbrktest(void)
     wait();
   }
 
-  // if we run the system out of memory, does it clean up the last
-  // failed allocation?
+  /// if we run the system out of memory, does it clean up the last
+  /// failed allocation?
   if(pipe(fds) != 0){
     printf(1, "pipe() failed\n");
     exit();
   }
   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
     if((pids[i] = fork()) == 0){
-      // allocate a lot of memory
+      /// allocate a lot of memory
       sbrk(BIG - (uint)sbrk(0));
       write(fds[1], "x", 1);
-      // sit around until killed
+      /// sit around until killed
       for(;;) sleep(1000);
     }
     if(pids[i] != -1)
       read(fds[0], &scratch, 1);
   }
-  // if those failed allocations freed up the pages they did allocate,
-  // we'll be able to allocate here
+  /// if those failed allocations freed up the pages they did allocate,
+  /// we'll be able to allocate here
   c = sbrk(4096);
   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
     if(pids[i] == -1)
@@ -1570,7 +1570,7 @@ validatetest(void)
 
   for(p = 0; p <= (uint)hi; p += 4096){
     if((pid = fork()) == 0){
-      // try to crash the kernel by passing in a badly placed integer
+      /// try to crash the kernel by passing in a badly placed integer
       validateint((int*)p);
       exit();
     }
@@ -1579,7 +1579,7 @@ validatetest(void)
     kill(pid);
     wait();
 
-    // try to crash the kernel by passing in a bad string pointer
+    /// try to crash the kernel by passing in a bad string pointer
     if(link("nosuchfile", (char*)p) != -1){
       printf(stdout, "link should not succeed\n");
       exit();
@@ -1589,7 +1589,7 @@ validatetest(void)
   printf(stdout, "validate ok\n");
 }
 
-// does unintialized data start out zero?
+/// does unintialized data start out zero?
 char uninit[10000];
 void
 bsstest(void)
@@ -1606,9 +1606,9 @@ bsstest(void)
   printf(stdout, "bss test ok\n");
 }
 
-// does exec return an error if the arguments
-// are larger than a page? or does it write
-// below the stack and wreck the instructions/data?
+/// does exec return an error if the arguments
+/// are larger than a page? or does it write
+/// below the stack and wreck the instructions/data?
 void
 bigargtest(void)
 {
@@ -1642,8 +1642,8 @@ bigargtest(void)
   unlink("bigarg-ok");
 }
 
-// what happens when the file system runs out of blocks?
-// answer: balloc panics, so this test is not useful.
+/// what happens when the file system runs out of blocks?
+/// answer: balloc panics, so this test is not useful.
 void
 fsfull()
 {
@@ -1710,7 +1710,7 @@ uio()
   if(pid == 0){
     port = RTC_ADDR;
     val = 0x09;  /* year */
-    /* http://wiki.osdev.org/Inline_Assembly/Examples */
+    /* http:///wiki.osdev.org/Inline_Assembly/Examples */
     asm volatile("outb %0,%1"::"a"(val), "d" (port));
     port = RTC_DATA;
     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
@@ -1793,7 +1793,7 @@ main(int argc, char *argv[])
   dirfile();
   iref();
   forktest();
-  bigdir(); // slow
+  bigdir(); /// slow
 
   uio();
 
diff --git a/usys.S b/usys.S
old mode 100644
new mode 100755
index 8bfd8a1..2ac5ed0
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,9 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(listen)
+SYSCALL(connect)
+SYSCALL(send)
+SYSCALL(recv)
+SYSCALL(disconnect)
+
diff --git a/vm.c b/vm.c
old mode 100644
new mode 100755
index 7134cff..c251d2f
--- a/vm.c
+++ b/vm.c
@@ -7,20 +7,20 @@
 #include "proc.h"
 #include "elf.h"
 
-extern char data[];  // defined by kernel.ld
-pde_t *kpgdir;  // for use in scheduler()
+extern char data[];  /// defined by kernel.ld
+pde_t *kpgdir;  /// for use in scheduler()
 
-// Set up CPU's kernel segment descriptors.
-// Run once on entry on each CPU.
+/// Set up CPU's kernel segment descriptors.
+/// Run once on entry on each CPU.
 void
 seginit(void)
 {
   struct cpu *c;
 
-  // Map "logical" addresses to virtual addresses using identity map.
-  // Cannot share a CODE descriptor for both kernel and user
-  // because it would have to have DPL_USR, but the CPU forbids
-  // an interrupt from CPL=0 to DPL=3.
+  /// Map "logical" addresses to virtual addresses using identity map.
+  /// Cannot share a CODE descriptor for both kernel and user
+  /// because it would have to have DPL_USR, but the CPU forbids
+  /// an interrupt from CPL=0 to DPL=3.
   c = &cpus[cpuid()];
   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
@@ -29,9 +29,9 @@ seginit(void)
   lgdt(c->gdt, sizeof(c->gdt));
 }
 
-// Return the address of the PTE in page table pgdir
-// that corresponds to virtual address va.  If alloc!=0,
-// create any required page table pages.
+/// Return the address of the PTE in page table pgdir
+/// that corresponds to virtual address va.  If alloc!=0,
+/// create any required page table pages.
 static pte_t *
 walkpgdir(pde_t *pgdir, const void *va, int alloc)
 {
@@ -44,19 +44,19 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
   } else {
     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
       return 0;
-    // Make sure all those PTE_P bits are zero.
+    /// Make sure all those PTE_P bits are zero.
     memset(pgtab, 0, PGSIZE);
-    // The permissions here are overly generous, but they can
-    // be further restricted by the permissions in the page table
-    // entries, if necessary.
+    /// The permissions here are overly generous, but they can
+    /// be further restricted by the permissions in the page table
+    /// entries, if necessary.
     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
   }
   return &pgtab[PTX(va)];
 }
 
-// Create PTEs for virtual addresses starting at va that refer to
-// physical addresses starting at pa. va and size might not
-// be page-aligned.
+/// Create PTEs for virtual addresses starting at va that refer to
+/// physical addresses starting at pa. va and size might not
+/// be page-aligned.
 static int
 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
 {
@@ -79,42 +79,42 @@ mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
   return 0;
 }
 
-// There is one page table per process, plus one that's used when
-// a CPU is not running any process (kpgdir). The kernel uses the
-// current process's page table during system calls and interrupts;
-// page protection bits prevent user code from using the kernel's
-// mappings.
-//
-// setupkvm() and exec() set up every page table like this:
-//
-//   0..KERNBASE: user memory (text+data+stack+heap), mapped to
-//                phys memory allocated by the kernel
-//   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
-//   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
-//                for the kernel's instructions and r/o data
-//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
-//                                  rw data + free physical memory
-//   0xfe000000..0: mapped direct (devices such as ioapic)
-//
-// The kernel allocates physical memory for its heap and for user memory
-// between V2P(end) and the end of physical memory (PHYSTOP)
-// (directly addressable from end..P2V(PHYSTOP)).
-
-// This table defines the kernel's mappings, which are present in
-// every process's page table.
+/// There is one page table per process, plus one that's used when
+/// a CPU is not running any process (kpgdir). The kernel uses the
+/// current process's page table during system calls and interrupts;
+/// page protection bits prevent user code from using the kernel's
+/// mappings.
+///
+/// setupkvm() and exec() set up every page table like this:
+///
+///   0..KERNBASE: user memory (text+data+stack+heap), mapped to
+///                phys memory allocated by the kernel
+///   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
+///   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
+///                for the kernel's instructions and r/o data
+///   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
+///                                  rw data + free physical memory
+///   0xfe000000..0: mapped direct (devices such as ioapic)
+///
+/// The kernel allocates physical memory for its heap and for user memory
+/// between V2P(end) and the end of physical memory (PHYSTOP)
+/// (directly addressable from end..P2V(PHYSTOP)).
+
+/// This table defines the kernel's mappings, which are present in
+/// every process's page table.
 static struct kmap {
   void *virt;
   uint phys_start;
   uint phys_end;
   int perm;
 } kmap[] = {
- { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
- { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
- { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
- { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
+ { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, /// I/O space
+ { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     /// kern text+rodata
+ { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, /// kern data+memory
+ { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, /// more devices
 };
 
-// Set up kernel part of a page table.
+/// Set up kernel part of a page table.
 pde_t*
 setupkvm(void)
 {
@@ -135,8 +135,8 @@ setupkvm(void)
   return pgdir;
 }
 
-// Allocate one page table for the machine for the kernel address
-// space for scheduler processes.
+/// Allocate one page table for the machine for the kernel address
+/// space for scheduler processes.
 void
 kvmalloc(void)
 {
@@ -144,15 +144,15 @@ kvmalloc(void)
   switchkvm();
 }
 
-// Switch h/w page table register to the kernel-only page table,
-// for when no process is running.
+/// Switch h/w page table register to the kernel-only page table,
+/// for when no process is running.
 void
 switchkvm(void)
 {
-  lcr3(V2P(kpgdir));   // switch to the kernel page table
+  lcr3(V2P(kpgdir));   /// switch to the kernel page table
 }
 
-// Switch TSS and h/w page table to correspond to process p.
+/// Switch TSS and h/w page table to correspond to process p.
 void
 switchuvm(struct proc *p)
 {
@@ -169,16 +169,16 @@ switchuvm(struct proc *p)
   mycpu()->gdt[SEG_TSS].s = 0;
   mycpu()->ts.ss0 = SEG_KDATA << 3;
   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
-  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
-  // forbids I/O instructions (e.g., inb and outb) from user space
+  /// setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
+  /// forbids I/O instructions (e.g., inb and outb) from user space
   mycpu()->ts.iomb = (ushort) 0xFFFF;
   ltr(SEG_TSS << 3);
-  lcr3(V2P(p->pgdir));  // switch to process's address space
+  lcr3(V2P(p->pgdir));  /// switch to process's address space
   popcli();
 }
 
-// Load the initcode into address 0 of pgdir.
-// sz must be less than a page.
+/// Load the initcode into address 0 of pgdir.
+/// sz must be less than a page.
 void
 inituvm(pde_t *pgdir, char *init, uint sz)
 {
@@ -192,8 +192,8 @@ inituvm(pde_t *pgdir, char *init, uint sz)
   memmove(mem, init, sz);
 }
 
-// Load a program segment into pgdir.  addr must be page-aligned
-// and the pages from addr to addr+sz must already be mapped.
+/// Load a program segment into pgdir.  addr must be page-aligned
+/// and the pages from addr to addr+sz must already be mapped.
 int
 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
 {
@@ -216,8 +216,8 @@ loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
   return 0;
 }
 
-// Allocate page tables and physical memory to grow process from oldsz to
-// newsz, which need not be page aligned.  Returns new size or 0 on error.
+/// Allocate page tables and physical memory to grow process from oldsz to
+/// newsz, which need not be page aligned.  Returns new size or 0 on error.
 int
 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
@@ -248,10 +248,10 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
   return newsz;
 }
 
-// Deallocate user pages to bring the process size from oldsz to
-// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
-// need to be less than oldsz.  oldsz can be larger than the actual
-// process size.  Returns the new process size.
+/// Deallocate user pages to bring the process size from oldsz to
+/// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+/// need to be less than oldsz.  oldsz can be larger than the actual
+/// process size.  Returns the new process size.
 int
 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
@@ -278,8 +278,8 @@ deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
   return newsz;
 }
 
-// Free a page table and all the physical memory pages
-// in the user part.
+/// Free a page table and all the physical memory pages
+/// in the user part.
 void
 freevm(pde_t *pgdir)
 {
@@ -297,8 +297,8 @@ freevm(pde_t *pgdir)
   kfree((char*)pgdir);
 }
 
-// Clear PTE_U on a page. Used to create an inaccessible
-// page beneath the user stack.
+/// Clear PTE_U on a page. Used to create an inaccessible
+/// page beneath the user stack.
 void
 clearpteu(pde_t *pgdir, char *uva)
 {
@@ -310,8 +310,8 @@ clearpteu(pde_t *pgdir, char *uva)
   *pte &= ~PTE_U;
 }
 
-// Given a parent process's page table, create a copy
-// of it for a child.
+/// Given a parent process's page table, create a copy
+/// of it for a child.
 pde_t*
 copyuvm(pde_t *pgdir, uint sz)
 {
@@ -344,8 +344,8 @@ bad:
   return 0;
 }
 
-//PAGEBREAK!
-// Map user virtual address to kernel address.
+///PAGEBREAK!
+/// Map user virtual address to kernel address.
 char*
 uva2ka(pde_t *pgdir, char *uva)
 {
@@ -359,9 +359,9 @@ uva2ka(pde_t *pgdir, char *uva)
   return (char*)P2V(PTE_ADDR(*pte));
 }
 
-// Copy len bytes from p to user address va in page table pgdir.
-// Most useful when pgdir is not the current page table.
-// uva2ka ensures this only works for PTE_U pages.
+/// Copy len bytes from p to user address va in page table pgdir.
+/// Most useful when pgdir is not the current page table.
+/// uva2ka ensures this only works for PTE_U pages.
 int
 copyout(pde_t *pgdir, uint va, void *p, uint len)
 {
@@ -385,10 +385,10 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
   return 0;
 }
 
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
+///PAGEBREAK!
+/// Blank page.
+///PAGEBREAK!
+/// Blank page.
+///PAGEBREAK!
+/// Blank page.
 
diff --git a/wc.c b/wc.c
old mode 100644
new mode 100755
diff --git a/x86.h b/x86.h
old mode 100644
new mode 100755
index 07312a5..09c0682
--- a/x86.h
+++ b/x86.h
@@ -1,4 +1,4 @@
-// Routines to let C code use special x86 instructions.
+/// Routines to let C code use special x86 instructions.
 
 static inline uchar
 inb(ushort port)
@@ -122,7 +122,7 @@ xchg(volatile uint *addr, uint newval)
 {
   uint result;
 
-  // The + in "+m" denotes a read-modify-write operand.
+  /// The + in "+m" denotes a read-modify-write operand.
   asm volatile("lock; xchgl %0, %1" :
                "+m" (*addr), "=a" (result) :
                "1" (newval) :
@@ -144,21 +144,21 @@ lcr3(uint val)
   asm volatile("movl %0,%%cr3" : : "r" (val));
 }
 
-//PAGEBREAK: 36
-// Layout of the trap frame built on the stack by the
-// hardware and by trapasm.S, and passed to trap().
+///PAGEBREAK: 36
+/// Layout of the trap frame built on the stack by the
+/// hardware and by trapasm.S, and passed to trap().
 struct trapframe {
-  // registers as pushed by pusha
+  /// registers as pushed by pusha
   uint edi;
   uint esi;
   uint ebp;
-  uint oesp;      // useless & ignored
+  uint oesp;      /// useless & ignored
   uint ebx;
   uint edx;
   uint ecx;
   uint eax;
 
-  // rest of trap frame
+  /// rest of trap frame
   ushort gs;
   ushort padding1;
   ushort fs;
@@ -169,14 +169,14 @@ struct trapframe {
   ushort padding4;
   uint trapno;
 
-  // below here defined by x86 hardware
+  /// below here defined by x86 hardware
   uint err;
   uint eip;
   ushort cs;
   ushort padding5;
   uint eflags;
 
-  // below here only when crossing rings, such as from user to kernel
+  /// below here only when crossing rings, such as from user to kernel
   uint esp;
   ushort ss;
   ushort padding6;
diff --git a/xv6-public.cbp b/xv6-public.cbp
new file mode 100755
index 0000000..d479c13
--- /dev/null
+++ b/xv6-public.cbp
@@ -0,0 +1,241 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="6" />
+	<Project>
+		<Option title="xv6-public" />
+		<Option pch_mode="2" />
+		<Option compiler="gcc" />
+		<Build>
+			<Target title="Debug">
+				<Option output="bin/Debug/xv6-public" prefix_auto="1" extension_auto="1" />
+				<Option object_output="obj/Debug/" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Compiler>
+					<Add option="-g" />
+				</Compiler>
+			</Target>
+			<Target title="Release">
+				<Option output="bin/Release/xv6-public" prefix_auto="1" extension_auto="1" />
+				<Option object_output="obj/Release/" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Compiler>
+					<Add option="-O2" />
+				</Compiler>
+				<Linker>
+					<Add option="-s" />
+				</Linker>
+			</Target>
+		</Build>
+		<Compiler>
+			<Add option="-Wall" />
+		</Compiler>
+		<Unit filename="BUGS" />
+		<Unit filename="LICENSE" />
+		<Unit filename="Makefile" />
+		<Unit filename="Notes" />
+		<Unit filename="README" />
+		<Unit filename="TRICKS" />
+		<Unit filename="asm.h" />
+		<Unit filename="bio.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="bootasm.S" />
+		<Unit filename="bootmain.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="buf.h" />
+		<Unit filename="cat.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="console.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="cuth" />
+		<Unit filename="date.h" />
+		<Unit filename="defs.h" />
+		<Unit filename="dot-bochsrc" />
+		<Unit filename="echo.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="elf.h" />
+		<Unit filename="entry.S" />
+		<Unit filename="entryother.S" />
+		<Unit filename="exec.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="fcntl.h" />
+		<Unit filename="file.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="file.h" />
+		<Unit filename="forktest.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="fs.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="fs.h" />
+		<Unit filename="gdbutil" />
+		<Unit filename="grep.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="ide.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="init.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="initcode.S" />
+		<Unit filename="ioapic.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="kalloc.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="kbd.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="kbd.h" />
+		<Unit filename="kernel.ld" />
+		<Unit filename="kill.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="lapic.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="ln.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="log.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="ls.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="main.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="memide.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="memlayout.h" />
+		<Unit filename="mkdir.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="mkfs.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="mmu.h" />
+		<Unit filename="mp.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="mp.h" />
+		<Unit filename="param.h" />
+		<Unit filename="picirq.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="pipe.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="pr.pl" />
+		<Unit filename="printf.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="printpcs" />
+		<Unit filename="proc.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="proc.h" />
+		<Unit filename="rm.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="runoff" />
+		<Unit filename="runoff.list" />
+		<Unit filename="runoff.spec" />
+		<Unit filename="runoff1" />
+		<Unit filename="sh.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="show1" />
+		<Unit filename="sign.pl" />
+		<Unit filename="sleep1.p" />
+		<Unit filename="sleeplock.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="sleeplock.h" />
+		<Unit filename="sock.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="sock.h" />
+		<Unit filename="sockparam.h" />
+		<Unit filename="socktest.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="spinlock.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="spinlock.h" />
+		<Unit filename="spinp" />
+		<Unit filename="stat.h" />
+		<Unit filename="stressfs.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="string.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="swtch.S" />
+		<Unit filename="syscall.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="syscall.h" />
+		<Unit filename="sysfile.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="sysproc.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="syssock.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="toc.ftr" />
+		<Unit filename="toc.hdr" />
+		<Unit filename="trap.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="trapasm.S" />
+		<Unit filename="traps.h" />
+		<Unit filename="types.h" />
+		<Unit filename="uart.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="ulib.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="umalloc.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="user.h" />
+		<Unit filename="usertests.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="usys.S" />
+		<Unit filename="vectors.pl" />
+		<Unit filename="vm.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="wc.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="x86.h" />
+		<Unit filename="xv6_SocketStub_patch" />
+		<Unit filename="zombie.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Extensions>
+			<code_completion />
+			<debugger />
+		</Extensions>
+	</Project>
+</CodeBlocks_project_file>
diff --git a/xv6-public.layout b/xv6-public.layout
new file mode 100755
index 0000000..0337b75
--- /dev/null
+++ b/xv6-public.layout
@@ -0,0 +1,390 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_layout_file>
+	<FileVersion major="1" minor="0" />
+	<ActiveTarget name="Debug" />
+	<File name="forktest.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="40" topLine="9" />
+		</Cursor>
+	</File>
+	<File name="entryother.S" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1515" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="zombie.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="174" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="sysfile.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="4557" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="sleeplock.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="243" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="printf.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1343" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="stat.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="276" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="traps.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1381" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="file.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="642" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="proc.c" open="1" top="0" tabpos="5" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="6658" topLine="294" />
+		</Cursor>
+	</File>
+	<File name="sysproc.c" open="1" top="0" tabpos="7" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="195" topLine="1" />
+		</Cursor>
+	</File>
+	<File name="lapic.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="5917" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="pr.pl" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="371" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="sleeplock.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="3" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="kbd.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="537" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="sh.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="7416" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="types.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="110" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="Makefile" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="5653" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="spinlock.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="295" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="xv6_SocketStub_patch" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="8427" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="syssock.c" open="1" top="1" tabpos="8" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="2981" topLine="132" />
+		</Cursor>
+	</File>
+	<File name="README" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="2204" topLine="16" />
+		</Cursor>
+	</File>
+	<File name="console.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="4814" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="mp.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="3148" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="uart.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="899" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="mkfs.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="5297" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="sock.c" open="1" top="0" tabpos="6" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="9101" topLine="357" />
+		</Cursor>
+	</File>
+	<File name="picirq.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="420" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="ioapic.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1933" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="ulib.c" open="1" top="0" tabpos="11" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="127" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="fs.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1622" topLine="23" />
+		</Cursor>
+	</File>
+	<File name="pipe.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="2368" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="entry.S" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="283" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="umalloc.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="125" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="grep.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1817" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="fs.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="15540" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="runoff" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="3335" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="bootasm.S" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1458" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="log.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="5676" topLine="200" />
+		</Cursor>
+	</File>
+	<File name="user.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="847" topLine="14" />
+		</Cursor>
+	</File>
+	<File name="exec.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="2387" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="memide.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="669" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="buf.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="293" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="bio.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="3418" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="param.h" open="1" top="0" tabpos="9" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="26" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="runoff1" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="275" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="bootmain.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="2177" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="mp.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="2175" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="mmu.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="5923" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="trap.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="2540" topLine="78" />
+		</Cursor>
+	</File>
+	<File name="socktest.c" open="1" top="0" tabpos="1" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1219" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="sock.h" open="1" top="0" tabpos="4" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="337" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="sleep1.p" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="218" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="kbd.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="3369" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="asm.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="730" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="kalloc.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1924" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="string.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1141" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="initcode.S" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="188" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="ide.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="3503" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="sockparam.h" open="1" top="0" tabpos="2" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="399" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="main.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="3352" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="x86.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="3166" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="vm.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="9985" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="elf.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="631" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="usys.S" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="0" topLine="7" />
+		</Cursor>
+	</File>
+	<File name="defs.h" open="1" top="0" tabpos="10" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="4715" topLine="144" />
+		</Cursor>
+	</File>
+	<File name="stressfs.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="809" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="TRICKS" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="3646" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="init.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="313" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="file.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="2332" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="ls.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="261" topLine="51" />
+		</Cursor>
+	</File>
+	<File name="usertests.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="34710" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="syscall.c" open="1" top="0" tabpos="12" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1410" topLine="34" />
+		</Cursor>
+	</File>
+	<File name="memlayout.h" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="644" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="spinlock.c" open="0" top="0" tabpos="0" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="2424" topLine="0" />
+		</Cursor>
+	</File>
+	<File name="proc.h" open="1" top="0" tabpos="3" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="1294" topLine="28" />
+		</Cursor>
+	</File>
+	<File name="syscall.h" open="0" top="0" tabpos="8" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
+		<Cursor>
+			<Cursor1 position="3" topLine="0" />
+		</Cursor>
+	</File>
+</CodeBlocks_layout_file>
diff --git a/zombie.c b/zombie.c
old mode 100644
new mode 100755
index ee817da..e500f71
--- a/zombie.c
+++ b/zombie.c
@@ -1,5 +1,5 @@
-// Create a zombie process that
-// must be reparented at exit.
+/// Create a zombie process that
+/// must be reparented at exit.
 
 #include "types.h"
 #include "stat.h"
@@ -9,6 +9,6 @@ int
 main(void)
 {
   if(fork() > 0)
-    sleep(5);  // Let child exit before parent.
+    sleep(5);  /// Let child exit before parent.
   exit();
 }
